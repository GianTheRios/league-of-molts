<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>League of Molts - Demo Mode</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0b0d;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    .container {
      display: grid;
      grid-template-rows: 60px 1fr 90px;
      grid-template-columns: 1fr 220px;
      height: 100vh;
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, rgba(10,11,13,0.95) 0%, rgba(10,11,13,0.8) 100%);
      border-bottom: 1px solid #1a1c24;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 20px;
      z-index: 100;
    }

    .team-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .team-label {
      font-size: 11px;
      font-weight: bold;
      letter-spacing: 2px;
    }

    .team-label.blue { color: #3498db; }
    .team-label.red { color: #e74c3c; }

    .champions {
      display: flex;
      gap: 6px;
    }

    .portrait {
      width: 44px;
      height: 44px;
      border-radius: 6px;
      border: 2px solid;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      font-weight: bold;
      font-size: 14px;
    }

    .portrait.blue { border-color: #3498db; background: linear-gradient(135deg, #1a3a5c 0%, #0d1f33 100%); }
    .portrait.red { border-color: #e74c3c; background: linear-gradient(135deg, #5c1a1a 0%, #330d0d 100%); }
    .portrait.dead { opacity: 0.4; }

    .portrait .level {
      position: absolute;
      bottom: -3px;
      right: -3px;
      background: #0a0b0d;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      color: #f1c40f;
      border: 1px solid #2a2c35;
    }

    .portrait .hp-bar-container {
      position: absolute;
      bottom: 3px;
      left: 3px;
      right: 3px;
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      overflow: hidden;
    }

    .portrait .hp-bar {
      height: 100%;
      background: #2ecc71;
      transition: width 0.3s;
    }

    .center-section {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .match-time {
      font-size: 24px;
      font-weight: bold;
      font-family: monospace;
      color: #f0f0f0;
    }

    .score {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 20px;
      font-weight: bold;
    }

    .score .blue { color: #5dade2; }
    .score .red { color: #ec7063; }
    .score .divider { color: #444; }

    /* Game Area */
    .game-area {
      background: #0d1117;
      position: relative;
      overflow: hidden;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 50;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      background: rgba(0,0,0,0.7);
      border: 1px solid #2a2c35;
      border-radius: 6px;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .zoom-btn:hover {
      background: rgba(50,50,50,0.8);
    }

    .zoom-level {
      text-align: center;
      font-size: 11px;
      color: #888;
      padding: 4px;
    }

    /* Kill Feed */
    .kill-feed {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 50;
      pointer-events: none;
    }

    .kill-entry {
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(4px);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .kill-entry.blue { border-left: 3px solid #5dade2; }
    .kill-entry.red { border-left: 3px solid #ec7063; }
    .kill-entry .killer { font-weight: 600; }
    .kill-entry .killer.blue { color: #5dade2; }
    .kill-entry .killer.red { color: #ec7063; }
    .kill-entry .victim.blue { color: #5dade2; }
    .kill-entry .victim.red { color: #ec7063; }
    .kill-entry .icon { opacity: 0.7; }

    /* Sidebar */
    .sidebar {
      background: rgba(10,11,13,0.95);
      border-left: 1px solid #1a1c24;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }

    .minimap-container {
      background: #0d1117;
      border-radius: 6px;
      padding: 8px;
      border: 1px solid #1a1c24;
    }

    #minimapCanvas {
      display: block;
      width: 100%;
      border-radius: 4px;
    }

    .panel {
      background: #0d1117;
      border-radius: 6px;
      padding: 12px;
      border: 1px solid #1a1c24;
    }

    .panel-title {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      padding: 4px 0;
    }

    .stat-label { color: #888; }
    .stat-value { color: #fff; }
    .stat-value.blue { color: #5dade2; }
    .stat-value.red { color: #ec7063; }

    /* Footer / Commentary */
    .footer {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, rgba(13,17,23,0.95) 0%, rgba(10,11,13,0.98) 100%);
      border-top: 1px solid #1a1c24;
      display: flex;
      flex-direction: column;
    }

    .commentary-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 16px;
      border-bottom: 1px solid #1a1c24;
      font-size: 12px;
      color: #666;
    }

    .commentary-lines {
      flex: 1;
      overflow-y: auto;
      padding: 8px 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .commentary-line {
      color: #999;
      font-size: 13px;
      line-height: 1.4;
      animation: fadeIn 0.5s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .commentary-line.kill { color: #e74c3c; font-weight: 500; }
    .commentary-line.objective { color: #f1c40f; font-weight: 500; }
    .commentary-line.ability { color: #9b59b6; }

    /* Demo Controls */
    .demo-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 50;
    }

    .demo-btn {
      padding: 8px 16px;
      background: rgba(0,0,0,0.7);
      border: 1px solid #2a2c35;
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .demo-btn:hover {
      background: rgba(50,50,50,0.8);
      border-color: #3498db;
    }

    .demo-btn.active {
      background: #3498db;
      border-color: #3498db;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="team-section">
        <div class="team-label blue">BLUE</div>
        <div class="champions" id="blueChampions"></div>
      </div>

      <div class="center-section">
        <div class="score">
          <span class="blue" id="blueKills">0</span>
          <span class="divider">-</span>
          <span class="red" id="redKills">0</span>
        </div>
        <div class="match-time" id="matchTime">00:00</div>
      </div>

      <div class="team-section">
        <div class="champions" id="redChampions"></div>
        <div class="team-label red">RED</div>
      </div>
    </header>

    <!-- Game Area -->
    <div class="game-area" id="gameArea">
      <canvas id="gameCanvas"></canvas>

      <div class="demo-controls">
        <button class="demo-btn active" id="playPauseBtn">Pause</button>
        <button class="demo-btn" id="speedBtn">1x</button>
        <button class="demo-btn" id="resetBtn">Reset</button>
      </div>

      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn">+</button>
        <div class="zoom-level" id="zoomLevel">100%</div>
        <button class="zoom-btn" id="zoomOut">-</button>
      </div>

      <div class="kill-feed" id="killFeed"></div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <div class="minimap-container">
        <canvas id="minimapCanvas" width="196" height="196"></canvas>
      </div>

      <div class="panel">
        <div class="panel-title">Match Stats</div>
        <div class="stat-row">
          <span class="stat-label">Towers</span>
          <span><span class="stat-value blue" id="blueTowers">2</span> - <span class="stat-value red" id="redTowers">2</span></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Gold</span>
          <span><span class="stat-value blue" id="blueGold">0</span> - <span class="stat-value red" id="redGold">0</span></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Minions</span>
          <span><span class="stat-value blue" id="blueMinions">0</span> - <span class="stat-value red" id="redMinions">0</span></span>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">Selected Unit</div>
        <div id="selectedInfo">
          <div class="stat-row">
            <span class="stat-label">Click a unit</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <div class="commentary-header">
        <span>üéôÔ∏è</span>
        <span>Live Commentary</span>
      </div>
      <div class="commentary-lines" id="commentaryLines"></div>
    </footer>
  </div>

  <script>
    // ============================================
    // GAME CONFIGURATION
    // ============================================
    const CONFIG = {
      // Map dimensions (game units)
      MAP_WIDTH: 12000,
      MAP_HEIGHT: 12000,

      // Lane runs diagonally from bottom-left to top-right
      LANE_START: { x: 1000, y: 11000 },  // Blue base (bottom-left)
      LANE_END: { x: 11000, y: 1000 },     // Red base (top-right)
      LANE_WIDTH: 600,

      // Tower positions along the lane (0 = blue base, 1 = red base)
      BLUE_TOWERS: [0.15, 0.30],  // Outer and inner
      RED_TOWERS: [0.85, 0.70],

      // Nexus positions
      BLUE_NEXUS: { x: 800, y: 11200 },
      RED_NEXUS: { x: 11200, y: 800 },

      // Spawning
      MINION_SPAWN_INTERVAL: 5000,  // 5 seconds

      // Combat
      TOWER_RANGE: 600,
      TOWER_DAMAGE: 150,
      CHAMPION_ATTACK_RANGE: 200,
      MINION_ATTACK_RANGE: 150,

      // Movement speeds (units per second)
      MINION_SPEED: 300,
      CHAMPION_SPEED: 400,

      // Stats
      MINION_HP: 300,
      MINION_DAMAGE: 20,
      TOWER_HP: 3000,
      NEXUS_HP: 5000,
    };

    // ============================================
    // GAME STATE
    // ============================================
    const gameState = {
      running: true,
      speed: 1,
      matchTime: 0,

      // Camera
      camera: {
        x: CONFIG.MAP_WIDTH / 2,
        y: CONFIG.MAP_HEIGHT / 2,
        zoom: 0.08,
        minZoom: 0.04,
        maxZoom: 0.2,
      },

      // Teams
      blueTeam: {
        kills: 0,
        gold: 0,
        minionsKilled: 0,
        towers: [],
        nexus: null,
        champions: [],
        minions: [],
      },
      redTeam: {
        kills: 0,
        gold: 0,
        minionsKilled: 0,
        towers: [],
        nexus: null,
        champions: [],
        minions: [],
      },

      // Kill feed entries
      killFeed: [],
      commentary: [],

      // Selection
      selectedUnit: null,

      // Timers
      lastMinionSpawn: { blue: 0, red: 0 },
    };

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function lerpPoint(p1, p2, t) {
      return {
        x: lerp(p1.x, p2.x, t),
        y: lerp(p1.y, p2.y, t),
      };
    }

    function distance(p1, p2) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function normalize(p1, p2) {
      const d = distance(p1, p2);
      if (d === 0) return { x: 0, y: 0 };
      return {
        x: (p2.x - p1.x) / d,
        y: (p2.y - p1.y) / d,
      };
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function formatGold(gold) {
      if (gold >= 1000) {
        return (gold / 1000).toFixed(1) + 'k';
      }
      return gold.toString();
    }

    // ============================================
    // UNIT CLASSES
    // ============================================
    class Unit {
      constructor(team, x, y) {
        this.team = team;
        this.x = x;
        this.y = y;
        this.targetX = x;
        this.targetY = y;
        this.hp = 100;
        this.maxHp = 100;
        this.damage = 10;
        this.attackRange = 100;
        this.attackCooldown = 1000;
        this.lastAttack = 0;
        this.speed = 300;
        this.dead = false;
        this.target = null;
      }

      takeDamage(amount, attacker) {
        this.hp -= amount;
        if (this.hp <= 0) {
          this.hp = 0;
          this.dead = true;
          this.onDeath(attacker);
        }
      }

      onDeath(killer) {}

      update(dt, now) {
        if (this.dead) return;

        // Find target if none
        if (!this.target || this.target.dead) {
          this.target = this.findTarget();
        }

        if (this.target) {
          const dist = distance(this, this.target);

          if (dist <= this.attackRange) {
            // Attack
            if (now - this.lastAttack >= this.attackCooldown) {
              this.attack(this.target);
              this.lastAttack = now;
            }
          } else {
            // Move toward target
            this.moveToward(this.target, dt);
          }
        } else {
          // No target, move down lane
          this.moveDownLane(dt);
        }
      }

      moveToward(target, dt) {
        const dir = normalize(this, target);
        this.x += dir.x * this.speed * dt;
        this.y += dir.y * this.speed * dt;
      }

      moveDownLane(dt) {
        // Override in subclass
      }

      attack(target) {
        target.takeDamage(this.damage, this);
      }

      findTarget() {
        return null;
      }
    }

    class Minion extends Unit {
      constructor(team, x, y) {
        super(team, x, y);
        this.hp = CONFIG.MINION_HP;
        this.maxHp = CONFIG.MINION_HP;
        this.damage = CONFIG.MINION_DAMAGE;
        this.attackRange = CONFIG.MINION_ATTACK_RANGE;
        this.attackCooldown = 1000;
        this.speed = CONFIG.MINION_SPEED;
        this.type = 'minion';
        this.goldValue = 20;
      }

      moveDownLane(dt) {
        const target = this.team === 'blue' ? CONFIG.LANE_END : CONFIG.LANE_START;
        const dir = normalize(this, target);
        this.x += dir.x * this.speed * dt;
        this.y += dir.y * this.speed * dt;
      }

      findTarget() {
        const enemies = this.team === 'blue' ?
          [...gameState.redTeam.minions, ...gameState.redTeam.champions] :
          [...gameState.blueTeam.minions, ...gameState.blueTeam.champions];

        // Also consider towers
        const enemyTowers = this.team === 'blue' ? gameState.redTeam.towers : gameState.blueTeam.towers;
        const allEnemies = [...enemies.filter(e => !e.dead), ...enemyTowers.filter(t => !t.dead)];

        let closest = null;
        let closestDist = Infinity;

        for (const enemy of allEnemies) {
          const d = distance(this, enemy);
          if (d < closestDist && d < 500) {
            closest = enemy;
            closestDist = d;
          }
        }

        return closest;
      }

      onDeath(killer) {
        if (killer && killer.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.gold += this.goldValue;
          team.minionsKilled++;
        }
      }
    }

    class Champion extends Unit {
      constructor(team, name, x, y) {
        super(team, x, y);
        this.name = name;
        this.hp = 800;
        this.maxHp = 800;
        this.mana = 300;
        this.maxMana = 300;
        this.level = 1;
        this.damage = 60;
        this.attackRange = CONFIG.CHAMPION_ATTACK_RANGE;
        this.attackCooldown = 800;
        this.speed = CONFIG.CHAMPION_SPEED;
        this.type = 'champion';
        this.respawnTime = 0;
        this.goldValue = 300;
        this.killValue = 300;
      }

      findTarget() {
        const enemies = this.team === 'blue' ?
          [...gameState.redTeam.minions, ...gameState.redTeam.champions] :
          [...gameState.blueTeam.minions, ...gameState.blueTeam.champions];

        let closest = null;
        let closestDist = Infinity;

        for (const enemy of enemies) {
          if (enemy.dead) continue;
          const d = distance(this, enemy);
          if (d < closestDist) {
            closest = enemy;
            closestDist = d;
          }
        }

        return closest;
      }

      moveDownLane(dt) {
        // Champions move toward center of map for fights
        const center = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, 0.5);
        const dist = distance(this, center);

        if (dist > 500) {
          const dir = normalize(this, center);
          this.x += dir.x * this.speed * dt;
          this.y += dir.y * this.speed * dt;
        }
      }

      onDeath(killer) {
        this.respawnTime = 10 + this.level * 2;

        if (killer && killer.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.kills++;
          team.gold += this.killValue;

          addKillFeedEntry(killer, this);
          addCommentary(`${killer.name || 'A minion'} takes down ${this.name}!`, 'kill');
        }
      }

      respawn() {
        const spawnPos = this.team === 'blue' ? CONFIG.LANE_START : CONFIG.LANE_END;
        this.x = spawnPos.x + (Math.random() - 0.5) * 200;
        this.y = spawnPos.y + (Math.random() - 0.5) * 200;
        this.hp = this.maxHp;
        this.mana = this.maxMana;
        this.dead = false;
        this.target = null;
      }
    }

    class Tower extends Unit {
      constructor(team, x, y, isOuter) {
        super(team, x, y);
        this.hp = CONFIG.TOWER_HP;
        this.maxHp = CONFIG.TOWER_HP;
        this.damage = CONFIG.TOWER_DAMAGE;
        this.attackRange = CONFIG.TOWER_RANGE;
        this.attackCooldown = 1000;
        this.type = 'tower';
        this.isOuter = isOuter;
        this.goldValue = 150;
      }

      moveToward() {} // Towers don't move
      moveDownLane() {}

      findTarget() {
        // Prioritize minions, then champions
        const enemyMinions = this.team === 'blue' ? gameState.redTeam.minions : gameState.blueTeam.minions;
        const enemyChampions = this.team === 'blue' ? gameState.redTeam.champions : gameState.blueTeam.champions;

        for (const minion of enemyMinions) {
          if (!minion.dead && distance(this, minion) <= this.attackRange) {
            return minion;
          }
        }

        for (const champ of enemyChampions) {
          if (!champ.dead && distance(this, champ) <= this.attackRange) {
            return champ;
          }
        }

        return null;
      }

      onDeath(killer) {
        if (killer && killer.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.gold += this.goldValue;

          addCommentary(`${this.team.toUpperCase()} ${this.isOuter ? 'outer' : 'inner'} tower destroyed!`, 'objective');
        }
      }

      update(dt, now) {
        if (this.dead) return;

        this.target = this.findTarget();

        if (this.target && now - this.lastAttack >= this.attackCooldown) {
          this.attack(this.target);
          this.lastAttack = now;
        }
      }
    }

    class Nexus extends Unit {
      constructor(team, x, y) {
        super(team, x, y);
        this.hp = CONFIG.NEXUS_HP;
        this.maxHp = CONFIG.NEXUS_HP;
        this.type = 'nexus';
      }

      moveToward() {}
      moveDownLane() {}
      findTarget() { return null; }
      update() {}

      onDeath() {
        const winner = this.team === 'blue' ? 'RED' : 'BLUE';
        addCommentary(`VICTORY! ${winner} team wins the game!`, 'objective');
        gameState.running = false;
      }
    }

    // ============================================
    // GAME INITIALIZATION
    // ============================================
    function initGame() {
      // Create Blue towers
      CONFIG.BLUE_TOWERS.forEach((t, i) => {
        const pos = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, t);
        gameState.blueTeam.towers.push(new Tower('blue', pos.x, pos.y, i === 0));
      });

      // Create Red towers
      CONFIG.RED_TOWERS.forEach((t, i) => {
        const pos = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, t);
        gameState.redTeam.towers.push(new Tower('red', pos.x, pos.y, i === 0));
      });

      // Create Nexuses
      gameState.blueTeam.nexus = new Nexus('blue', CONFIG.BLUE_NEXUS.x, CONFIG.BLUE_NEXUS.y);
      gameState.redTeam.nexus = new Nexus('red', CONFIG.RED_NEXUS.x, CONFIG.RED_NEXUS.y);

      // Create Champions
      const blueSpawn = CONFIG.LANE_START;
      const redSpawn = CONFIG.LANE_END;

      const blueChamps = ['Ironclad', 'Voltaic', 'Shadebow'];
      const redChamps = ['Ironclad', 'Voltaic', 'Shadebow'];

      blueChamps.forEach((name, i) => {
        const champ = new Champion('blue', name,
          blueSpawn.x + (i - 1) * 150,
          blueSpawn.y + (i - 1) * -150
        );
        gameState.blueTeam.champions.push(champ);
      });

      redChamps.forEach((name, i) => {
        const champ = new Champion('red', name,
          redSpawn.x + (i - 1) * -150,
          redSpawn.y + (i - 1) * 150
        );
        gameState.redTeam.champions.push(champ);
      });

      // Initial commentary
      addCommentary('Welcome to League of Molts! The match is about to begin.', 'objective');
      addCommentary('Minions will spawn shortly...', '');

      updateUI();
    }

    // ============================================
    // SPAWNING
    // ============================================
    function spawnMinion(team) {
      const spawn = team === 'blue' ? CONFIG.LANE_START : CONFIG.LANE_END;
      const offset = (Math.random() - 0.5) * 100;

      const minion = new Minion(team, spawn.x + offset, spawn.y + offset);

      if (team === 'blue') {
        gameState.blueTeam.minions.push(minion);
      } else {
        gameState.redTeam.minions.push(minion);
      }
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;

    function gameLoop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1) * gameState.speed;
      lastTime = timestamp;

      if (gameState.running) {
        gameState.matchTime += dt;

        // Spawn minions every 5 seconds
        const now = gameState.matchTime * 1000;

        if (now - gameState.lastMinionSpawn.blue >= CONFIG.MINION_SPAWN_INTERVAL) {
          spawnMinion('blue');
          gameState.lastMinionSpawn.blue = now;
        }

        if (now - gameState.lastMinionSpawn.red >= CONFIG.MINION_SPAWN_INTERVAL) {
          spawnMinion('red');
          gameState.lastMinionSpawn.red = now;
        }

        // Update all units
        const allUnits = [
          ...gameState.blueTeam.towers,
          ...gameState.redTeam.towers,
          ...gameState.blueTeam.champions,
          ...gameState.redTeam.champions,
          ...gameState.blueTeam.minions,
          ...gameState.redTeam.minions,
        ];

        allUnits.forEach(unit => unit.update(dt, now));

        // Handle champion respawns
        [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(champ => {
          if (champ.dead && champ.respawnTime > 0) {
            champ.respawnTime -= dt;
            if (champ.respawnTime <= 0) {
              champ.respawn();
              addCommentary(`${champ.name} has respawned!`, '');
            }
          }
        });

        // Clean up dead minions
        gameState.blueTeam.minions = gameState.blueTeam.minions.filter(m => !m.dead);
        gameState.redTeam.minions = gameState.redTeam.minions.filter(m => !m.dead);

        updateUI();
      }

      render();
      requestAnimationFrame(gameLoop);
    }

    // ============================================
    // RENDERING
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimapCanvas');
    const minimapCtx = minimapCanvas.getContext('2d');

    function resizeCanvas() {
      const gameArea = document.getElementById('gameArea');
      canvas.width = gameArea.clientWidth;
      canvas.height = gameArea.clientHeight;
    }

    function worldToScreen(x, y) {
      const { camera } = gameState;
      return {
        x: (x - camera.x) * camera.zoom + canvas.width / 2,
        y: (y - camera.y) * camera.zoom + canvas.height / 2,
      };
    }

    function screenToWorld(sx, sy) {
      const { camera } = gameState;
      return {
        x: (sx - canvas.width / 2) / camera.zoom + camera.x,
        y: (sy - canvas.height / 2) / camera.zoom + camera.y,
      };
    }

    function render() {
      ctx.fillStyle = '#0d1117';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      renderGround();
      renderLane();
      renderJungle();
      renderStructures();
      renderUnits();
      renderMinimap();
    }

    function renderGround() {
      // Draw background grid for reference
      ctx.strokeStyle = '#1a1c24';
      ctx.lineWidth = 1;

      const gridSize = 500;
      for (let x = 0; x <= CONFIG.MAP_WIDTH; x += gridSize) {
        const start = worldToScreen(x, 0);
        const end = worldToScreen(x, CONFIG.MAP_HEIGHT);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      }
      for (let y = 0; y <= CONFIG.MAP_HEIGHT; y += gridSize) {
        const start = worldToScreen(0, y);
        const end = worldToScreen(CONFIG.MAP_WIDTH, y);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      }
    }

    function renderLane() {
      const start = worldToScreen(CONFIG.LANE_START.x, CONFIG.LANE_START.y);
      const end = worldToScreen(CONFIG.LANE_END.x, CONFIG.LANE_END.y);

      // Lane path
      ctx.strokeStyle = '#2a3a4a';
      ctx.lineWidth = CONFIG.LANE_WIDTH * gameState.camera.zoom;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();

      // Lane center line
      ctx.strokeStyle = '#3a4a5a';
      ctx.lineWidth = 2;
      ctx.setLineDash([20, 10]);
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function renderJungle() {
      // Draw trees/foliage in the jungle areas
      const treePositions = [];

      // Generate tree positions (seeded for consistency)
      for (let i = 0; i < 100; i++) {
        const angle = (i * 137.5) * Math.PI / 180;
        const radius = 2000 + (i % 20) * 300;
        const centerX = CONFIG.MAP_WIDTH / 2;
        const centerY = CONFIG.MAP_HEIGHT / 2;

        let x = centerX + Math.cos(angle) * radius;
        let y = centerY + Math.sin(angle) * radius;

        // Avoid the lane
        const laneCenter = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, 0.5);
        const distToLane = Math.abs((CONFIG.LANE_END.y - CONFIG.LANE_START.y) * x -
                                     (CONFIG.LANE_END.x - CONFIG.LANE_START.x) * y +
                                     CONFIG.LANE_END.x * CONFIG.LANE_START.y -
                                     CONFIG.LANE_END.y * CONFIG.LANE_START.x) /
                          distance(CONFIG.LANE_START, CONFIG.LANE_END);

        if (distToLane > 800 && x > 500 && x < CONFIG.MAP_WIDTH - 500 &&
            y > 500 && y < CONFIG.MAP_HEIGHT - 500) {
          treePositions.push({ x, y, size: 80 + (i % 5) * 20 });
        }
      }

      // Render trees
      treePositions.forEach(tree => {
        const pos = worldToScreen(tree.x, tree.y);
        const size = tree.size * gameState.camera.zoom;

        if (pos.x < -size || pos.x > canvas.width + size ||
            pos.y < -size || pos.y > canvas.height + size) return;

        // Tree shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(pos.x + size * 0.2, pos.y + size * 0.3, size * 0.4, size * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tree trunk
        ctx.fillStyle = '#3d2817';
        ctx.fillRect(pos.x - size * 0.1, pos.y - size * 0.2, size * 0.2, size * 0.4);

        // Tree canopy
        ctx.fillStyle = '#1a4a2a';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y - size * 0.3, size * 0.35, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#2a5a3a';
        ctx.beginPath();
        ctx.arc(pos.x - size * 0.15, pos.y - size * 0.4, size * 0.25, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function renderStructures() {
      // Render Nexuses
      [gameState.blueTeam.nexus, gameState.redTeam.nexus].forEach(nexus => {
        if (!nexus) return;
        const pos = worldToScreen(nexus.x, nexus.y);
        const size = 120 * gameState.camera.zoom;

        // Nexus glow
        const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, size);
        const color = nexus.team === 'blue' ? '#3498db' : '#e74c3c';
        gradient.addColorStop(0, color + '40');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fill();

        // Nexus structure
        ctx.fillStyle = nexus.team === 'blue' ? '#2980b9' : '#c0392b';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size * 0.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = nexus.team === 'blue' ? '#5dade2' : '#ec7063';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size * 0.35, 0, Math.PI * 2);
        ctx.fill();

        // Health bar
        renderHealthBar(pos.x, pos.y - size * 0.8, nexus.hp, nexus.maxHp, size * 1.2);
      });

      // Render Towers
      [...gameState.blueTeam.towers, ...gameState.redTeam.towers].forEach(tower => {
        if (tower.dead) return;
        const pos = worldToScreen(tower.x, tower.y);
        const size = 60 * gameState.camera.zoom;

        // Tower range indicator (faint)
        ctx.strokeStyle = tower.team === 'blue' ? '#3498db20' : '#e74c3c20';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, CONFIG.TOWER_RANGE * gameState.camera.zoom, 0, Math.PI * 2);
        ctx.stroke();

        // Tower shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y + size * 0.6, size * 0.5, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Tower base
        ctx.fillStyle = tower.team === 'blue' ? '#1a3a5c' : '#5c1a1a';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y + size * 0.2, size * 0.4, 0, Math.PI * 2);
        ctx.fill();

        // Tower body
        ctx.fillStyle = tower.team === 'blue' ? '#2980b9' : '#c0392b';
        ctx.fillRect(pos.x - size * 0.15, pos.y - size * 0.8, size * 0.3, size);

        // Tower top
        ctx.fillStyle = tower.team === 'blue' ? '#5dade2' : '#ec7063';
        ctx.beginPath();
        ctx.moveTo(pos.x - size * 0.25, pos.y - size * 0.8);
        ctx.lineTo(pos.x, pos.y - size * 1.1);
        ctx.lineTo(pos.x + size * 0.25, pos.y - size * 0.8);
        ctx.fill();

        // Health bar
        renderHealthBar(pos.x, pos.y - size * 1.3, tower.hp, tower.maxHp, size * 1.5);

        // Attack line if targeting
        if (tower.target && !tower.target.dead) {
          const targetPos = worldToScreen(tower.target.x, tower.target.y);
          ctx.strokeStyle = tower.team === 'blue' ? '#5dade280' : '#ec706380';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y - size * 0.5);
          ctx.lineTo(targetPos.x, targetPos.y);
          ctx.stroke();
        }
      });
    }

    function renderUnits() {
      // Render Minions
      [...gameState.blueTeam.minions, ...gameState.redTeam.minions].forEach(minion => {
        if (minion.dead) return;
        const pos = worldToScreen(minion.x, minion.y);
        const size = 20 * gameState.camera.zoom;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y + size * 0.5, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Body
        ctx.fillStyle = minion.team === 'blue' ? '#85c1e9' : '#f1948a';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fill();

        // Outline
        ctx.strokeStyle = minion.team === 'blue' ? '#3498db' : '#e74c3c';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Health bar (small)
        if (minion.hp < minion.maxHp) {
          renderHealthBar(pos.x, pos.y - size * 1.5, minion.hp, minion.maxHp, size * 2, true);
        }
      });

      // Render Champions
      [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(champ => {
        const pos = worldToScreen(champ.x, champ.y);
        const size = 35 * gameState.camera.zoom;

        if (champ.dead) {
          // Death marker
          ctx.fillStyle = 'rgba(100,100,100,0.5)';
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, size * 0.5, 0, Math.PI * 2);
          ctx.fill();

          // Respawn timer
          if (champ.respawnTime > 0) {
            ctx.fillStyle = '#fff';
            ctx.font = `${12 * gameState.camera.zoom / 0.08}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText(Math.ceil(champ.respawnTime) + 's', pos.x, pos.y + 5);
          }
          return;
        }

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y + size * 0.6, size * 0.7, size * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();

        // Body
        const gradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, size);
        if (champ.team === 'blue') {
          gradient.addColorStop(0, '#5dade2');
          gradient.addColorStop(1, '#2980b9');
        } else {
          gradient.addColorStop(0, '#ec7063');
          gradient.addColorStop(1, '#c0392b');
        }
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, size, 0, Math.PI * 2);
        ctx.fill();

        // Champion initial
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${size}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(champ.name[0], pos.x, pos.y);

        // Health bar
        renderHealthBar(pos.x, pos.y - size * 1.5, champ.hp, champ.maxHp, size * 2.5);

        // Level badge
        ctx.fillStyle = '#0a0b0d';
        ctx.beginPath();
        ctx.arc(pos.x + size * 0.8, pos.y + size * 0.6, size * 0.35, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#f1c40f';
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.fillStyle = '#f1c40f';
        ctx.font = `bold ${size * 0.4}px sans-serif`;
        ctx.fillText(champ.level, pos.x + size * 0.8, pos.y + size * 0.6);

        // Selection ring
        if (gameState.selectedUnit === champ) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, size * 1.3, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      });
    }

    function renderHealthBar(x, y, hp, maxHp, width, small = false) {
      const height = small ? 4 : 6;
      const hpPercent = hp / maxHp;

      // Background
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(x - width / 2, y, width, height);

      // Health
      let color = '#2ecc71';
      if (hpPercent < 0.3) color = '#e74c3c';
      else if (hpPercent < 0.6) color = '#f1c40f';

      ctx.fillStyle = color;
      ctx.fillRect(x - width / 2, y, width * hpPercent, height);

      // Border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - width / 2, y, width, height);
    }

    function renderMinimap() {
      const w = minimapCanvas.width;
      const h = minimapCanvas.height;

      // Background
      minimapCtx.fillStyle = '#0d1117';
      minimapCtx.fillRect(0, 0, w, h);

      // Border
      minimapCtx.strokeStyle = '#1a1c24';
      minimapCtx.lineWidth = 2;
      minimapCtx.strokeRect(0, 0, w, h);

      // Lane
      const scale = w / CONFIG.MAP_WIDTH;
      const laneStart = { x: CONFIG.LANE_START.x * scale, y: CONFIG.LANE_START.y * scale };
      const laneEnd = { x: CONFIG.LANE_END.x * scale, y: CONFIG.LANE_END.y * scale };

      minimapCtx.strokeStyle = '#2a3a4a';
      minimapCtx.lineWidth = 8;
      minimapCtx.lineCap = 'round';
      minimapCtx.beginPath();
      minimapCtx.moveTo(laneStart.x, laneStart.y);
      minimapCtx.lineTo(laneEnd.x, laneEnd.y);
      minimapCtx.stroke();

      // Nexuses
      minimapCtx.fillStyle = '#3498db';
      minimapCtx.beginPath();
      minimapCtx.arc(CONFIG.BLUE_NEXUS.x * scale, CONFIG.BLUE_NEXUS.y * scale, 8, 0, Math.PI * 2);
      minimapCtx.fill();

      minimapCtx.fillStyle = '#e74c3c';
      minimapCtx.beginPath();
      minimapCtx.arc(CONFIG.RED_NEXUS.x * scale, CONFIG.RED_NEXUS.y * scale, 8, 0, Math.PI * 2);
      minimapCtx.fill();

      // Towers
      [...gameState.blueTeam.towers, ...gameState.redTeam.towers].forEach(tower => {
        if (tower.dead) return;
        minimapCtx.fillStyle = tower.team === 'blue' ? '#2980b9' : '#c0392b';
        minimapCtx.fillRect(tower.x * scale - 3, tower.y * scale - 3, 6, 6);
      });

      // Champions
      [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(champ => {
        if (champ.dead) return;
        minimapCtx.fillStyle = champ.team === 'blue' ? '#5dade2' : '#ec7063';
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.lineWidth = 1;
        minimapCtx.beginPath();
        minimapCtx.arc(champ.x * scale, champ.y * scale, 5, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.stroke();
      });

      // Minions (small dots)
      [...gameState.blueTeam.minions, ...gameState.redTeam.minions].forEach(minion => {
        minimapCtx.fillStyle = minion.team === 'blue' ? '#85c1e9' : '#f1948a';
        minimapCtx.beginPath();
        minimapCtx.arc(minion.x * scale, minion.y * scale, 2, 0, Math.PI * 2);
        minimapCtx.fill();
      });

      // Camera viewport
      const { camera } = gameState;
      const vpLeft = (camera.x - canvas.width / 2 / camera.zoom) * scale;
      const vpTop = (camera.y - canvas.height / 2 / camera.zoom) * scale;
      const vpWidth = (canvas.width / camera.zoom) * scale;
      const vpHeight = (canvas.height / camera.zoom) * scale;

      minimapCtx.strokeStyle = '#ffffff80';
      minimapCtx.lineWidth = 1;
      minimapCtx.strokeRect(vpLeft, vpTop, vpWidth, vpHeight);
    }

    // ============================================
    // UI UPDATES
    // ============================================
    function updateUI() {
      // Match time
      document.getElementById('matchTime').textContent = formatTime(gameState.matchTime);

      // Scores
      document.getElementById('blueKills').textContent = gameState.blueTeam.kills;
      document.getElementById('redKills').textContent = gameState.redTeam.kills;

      // Stats
      document.getElementById('blueTowers').textContent = gameState.blueTeam.towers.filter(t => !t.dead).length;
      document.getElementById('redTowers').textContent = gameState.redTeam.towers.filter(t => !t.dead).length;
      document.getElementById('blueGold').textContent = formatGold(gameState.blueTeam.gold);
      document.getElementById('redGold').textContent = formatGold(gameState.redTeam.gold);
      document.getElementById('blueMinions').textContent = gameState.blueTeam.minionsKilled;
      document.getElementById('redMinions').textContent = gameState.redTeam.minionsKilled;

      // Champion portraits
      updateChampionPortraits();

      // Zoom level
      document.getElementById('zoomLevel').textContent = Math.round(gameState.camera.zoom * 100 / 0.08) + '%';
    }

    function updateChampionPortraits() {
      const blueContainer = document.getElementById('blueChampions');
      const redContainer = document.getElementById('redChampions');

      blueContainer.innerHTML = gameState.blueTeam.champions.map(champ => `
        <div class="portrait blue ${champ.dead ? 'dead' : ''}">
          ${champ.name[0]}
          <span class="level">${champ.level}</span>
          <div class="hp-bar-container">
            <div class="hp-bar" style="width: ${(champ.hp / champ.maxHp) * 100}%"></div>
          </div>
        </div>
      `).join('');

      redContainer.innerHTML = gameState.redTeam.champions.map(champ => `
        <div class="portrait red ${champ.dead ? 'dead' : ''}">
          ${champ.name[0]}
          <span class="level">${champ.level}</span>
          <div class="hp-bar-container">
            <div class="hp-bar" style="width: ${(champ.hp / champ.maxHp) * 100}%"></div>
          </div>
        </div>
      `).join('');
    }

    function addKillFeedEntry(killer, victim) {
      const entry = {
        killer: killer.name || 'Minion',
        killerTeam: killer.team,
        victim: victim.name || 'Minion',
        victimTeam: victim.team,
        timestamp: gameState.matchTime,
      };

      gameState.killFeed.unshift(entry);
      if (gameState.killFeed.length > 5) gameState.killFeed.pop();

      const killFeed = document.getElementById('killFeed');
      killFeed.innerHTML = gameState.killFeed.map(e => `
        <div class="kill-entry ${e.killerTeam}">
          <span class="killer ${e.killerTeam}">${e.killer}</span>
          <span class="icon">‚öî</span>
          <span class="victim ${e.victimTeam}">${e.victim}</span>
        </div>
      `).join('');
    }

    function addCommentary(text, type = '') {
      gameState.commentary.unshift({ text, type, timestamp: gameState.matchTime });
      if (gameState.commentary.length > 10) gameState.commentary.pop();

      const container = document.getElementById('commentaryLines');
      container.innerHTML = gameState.commentary.map(c => `
        <div class="commentary-line ${c.type}">${c.text}</div>
      `).join('');
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    function setupInput() {
      const gameArea = document.getElementById('gameArea');

      // Zoom with scroll
      gameArea.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        gameState.camera.zoom = Math.max(
          gameState.camera.minZoom,
          Math.min(gameState.camera.maxZoom, gameState.camera.zoom * zoomDelta)
        );
        updateUI();
      });

      // Pan with drag
      let isDragging = false;
      let lastMouseX, lastMouseY;

      gameArea.addEventListener('mousedown', (e) => {
        if (e.button === 0) {
          isDragging = true;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });

      window.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastMouseX;
          const dy = e.clientY - lastMouseY;
          gameState.camera.x -= dx / gameState.camera.zoom;
          gameState.camera.y -= dy / gameState.camera.zoom;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });

      window.addEventListener('mouseup', () => {
        isDragging = false;
      });

      // Click to select
      canvas.addEventListener('click', (e) => {
        if (isDragging) return;

        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const world = screenToWorld(screenX, screenY);

        // Find clicked unit
        const allUnits = [
          ...gameState.blueTeam.champions,
          ...gameState.redTeam.champions,
        ];

        let clicked = null;
        let closestDist = 50 / gameState.camera.zoom;

        for (const unit of allUnits) {
          if (unit.dead) continue;
          const d = distance(world, unit);
          if (d < closestDist) {
            clicked = unit;
            closestDist = d;
          }
        }

        gameState.selectedUnit = clicked;
        updateSelectedInfo();
      });

      // Minimap click to move camera
      minimapCanvas.addEventListener('click', (e) => {
        const rect = minimapCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / minimapCanvas.width * CONFIG.MAP_WIDTH;
        const y = (e.clientY - rect.top) / minimapCanvas.height * CONFIG.MAP_HEIGHT;
        gameState.camera.x = x;
        gameState.camera.y = y;
      });

      // Zoom buttons
      document.getElementById('zoomIn').addEventListener('click', () => {
        gameState.camera.zoom = Math.min(gameState.camera.maxZoom, gameState.camera.zoom * 1.2);
        updateUI();
      });

      document.getElementById('zoomOut').addEventListener('click', () => {
        gameState.camera.zoom = Math.max(gameState.camera.minZoom, gameState.camera.zoom / 1.2);
        updateUI();
      });

      // Demo controls
      document.getElementById('playPauseBtn').addEventListener('click', (e) => {
        gameState.running = !gameState.running;
        e.target.textContent = gameState.running ? 'Pause' : 'Play';
        e.target.classList.toggle('active', gameState.running);
      });

      document.getElementById('speedBtn').addEventListener('click', (e) => {
        const speeds = [1, 2, 4, 0.5];
        const currentIndex = speeds.indexOf(gameState.speed);
        gameState.speed = speeds[(currentIndex + 1) % speeds.length];
        e.target.textContent = gameState.speed + 'x';
      });

      document.getElementById('resetBtn').addEventListener('click', () => {
        location.reload();
      });

      // Window resize
      window.addEventListener('resize', resizeCanvas);
    }

    function updateSelectedInfo() {
      const container = document.getElementById('selectedInfo');
      const unit = gameState.selectedUnit;

      if (!unit) {
        container.innerHTML = '<div class="stat-row"><span class="stat-label">Click a champion</span></div>';
        return;
      }

      container.innerHTML = `
        <div class="stat-row">
          <span class="stat-label">Name</span>
          <span class="stat-value">${unit.name}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Team</span>
          <span class="stat-value ${unit.team}">${unit.team.toUpperCase()}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">HP</span>
          <span class="stat-value">${Math.round(unit.hp)}/${unit.maxHp}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Level</span>
          <span class="stat-value">${unit.level}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Damage</span>
          <span class="stat-value">${unit.damage}</span>
        </div>
      `;
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    resizeCanvas();
    setupInput();
    initGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
