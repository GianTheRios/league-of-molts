<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>League of Molts - Demo Mode</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0b0d;
      color: white;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    .container {
      display: grid;
      grid-template-rows: 60px 1fr 90px;
      grid-template-columns: 1fr 220px;
      height: 100vh;
    }

    /* Header */
    .header {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, rgba(10,11,13,0.95) 0%, rgba(10,11,13,0.8) 100%);
      border-bottom: 1px solid #1a1c24;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 20px;
      z-index: 100;
    }

    .team-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .team-label {
      font-size: 11px;
      font-weight: bold;
      letter-spacing: 2px;
    }

    .team-label.blue { color: #3498db; }
    .team-label.red { color: #e74c3c; }

    .champions {
      display: flex;
      gap: 6px;
    }

    .portrait {
      width: 44px;
      height: 44px;
      border-radius: 6px;
      border: 2px solid;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      font-weight: bold;
      font-size: 14px;
    }

    .portrait.blue { border-color: #3498db; background: linear-gradient(135deg, #1a3a5c 0%, #0d1f33 100%); }
    .portrait.red { border-color: #e74c3c; background: linear-gradient(135deg, #5c1a1a 0%, #330d0d 100%); }
    .portrait.dead { opacity: 0.4; }

    .portrait .level {
      position: absolute;
      bottom: -3px;
      right: -3px;
      background: #0a0b0d;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      color: #f1c40f;
      border: 1px solid #2a2c35;
    }

    .portrait .hp-bar-container {
      position: absolute;
      bottom: 3px;
      left: 3px;
      right: 3px;
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      overflow: hidden;
    }

    .portrait .hp-bar {
      height: 100%;
      background: #2ecc71;
      transition: width 0.3s;
    }

    .center-section {
      display: flex;
      align-items: center;
      gap: 20px;
    }

    .match-time {
      font-size: 24px;
      font-weight: bold;
      font-family: monospace;
      color: #f0f0f0;
    }

    .score {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 20px;
      font-weight: bold;
    }

    .score .blue { color: #5dade2; }
    .score .red { color: #ec7063; }
    .score .divider { color: #444; }

    /* Game Area */
    .game-area {
      background: #0d1117;
      position: relative;
      overflow: hidden;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Zoom Controls */
    .zoom-controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 50;
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      background: rgba(0,0,0,0.7);
      border: 1px solid #2a2c35;
      border-radius: 6px;
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .zoom-btn:hover {
      background: rgba(50,50,50,0.8);
    }

    .zoom-level {
      text-align: center;
      font-size: 11px;
      color: #888;
      padding: 4px;
    }

    /* Kill Feed */
    .kill-feed {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      z-index: 50;
      pointer-events: none;
    }

    .kill-entry {
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(4px);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from { transform: translateX(100px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .kill-entry.blue { border-left: 3px solid #5dade2; }
    .kill-entry.red { border-left: 3px solid #ec7063; }
    .kill-entry .killer { font-weight: 600; }
    .kill-entry .killer.blue { color: #5dade2; }
    .kill-entry .killer.red { color: #ec7063; }
    .kill-entry .victim.blue { color: #5dade2; }
    .kill-entry .victim.red { color: #ec7063; }
    .kill-entry .icon { opacity: 0.7; }

    /* Sidebar */
    .sidebar {
      background: rgba(10,11,13,0.95);
      border-left: 1px solid #1a1c24;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      overflow-y: auto;
    }

    .minimap-container {
      background: #0d1117;
      border-radius: 6px;
      padding: 8px;
      border: 1px solid #1a1c24;
    }

    #minimapCanvas {
      display: block;
      width: 100%;
      border-radius: 4px;
    }

    .panel {
      background: #0d1117;
      border-radius: 6px;
      padding: 12px;
      border: 1px solid #1a1c24;
    }

    .panel-title {
      font-size: 10px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      padding: 4px 0;
    }

    .stat-label { color: #888; }
    .stat-value { color: #fff; }
    .stat-value.blue { color: #5dade2; }
    .stat-value.red { color: #ec7063; }

    /* Footer / Commentary */
    .footer {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, rgba(13,17,23,0.95) 0%, rgba(10,11,13,0.98) 100%);
      border-top: 1px solid #1a1c24;
      display: flex;
      flex-direction: column;
    }

    .commentary-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 16px;
      border-bottom: 1px solid #1a1c24;
      font-size: 12px;
      color: #666;
    }

    .commentary-lines {
      flex: 1;
      overflow-y: auto;
      padding: 8px 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .commentary-line {
      color: #999;
      font-size: 13px;
      line-height: 1.4;
      animation: fadeIn 0.5s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .commentary-line.kill { color: #e74c3c; font-weight: 500; }
    .commentary-line.objective { color: #f1c40f; font-weight: 500; }
    .commentary-line.ability { color: #9b59b6; }

    /* Demo Controls */
    .demo-controls {
      position: absolute;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 50;
    }

    .demo-btn {
      padding: 8px 16px;
      background: rgba(0,0,0,0.7);
      border: 1px solid #2a2c35;
      border-radius: 6px;
      color: #fff;
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .demo-btn:hover {
      background: rgba(50,50,50,0.8);
      border-color: #3498db;
    }

    .demo-btn.active {
      background: #3498db;
      border-color: #3498db;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <header class="header">
      <div class="team-section">
        <div class="team-label blue">BLUE</div>
        <div class="champions" id="blueChampions"></div>
      </div>

      <div class="center-section">
        <div class="score">
          <span class="blue" id="blueKills">0</span>
          <span class="divider">-</span>
          <span class="red" id="redKills">0</span>
        </div>
        <div class="match-time" id="matchTime">00:00</div>
      </div>

      <div class="team-section">
        <div class="champions" id="redChampions"></div>
        <div class="team-label red">RED</div>
      </div>
    </header>

    <!-- Game Area -->
    <div class="game-area" id="gameArea">
      <canvas id="gameCanvas"></canvas>

      <div class="demo-controls">
        <button class="demo-btn active" id="playPauseBtn">Pause</button>
        <button class="demo-btn" id="speedBtn">1x</button>
        <button class="demo-btn" id="resetBtn">Reset</button>
      </div>

      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn">+</button>
        <div class="zoom-level" id="zoomLevel">100%</div>
        <button class="zoom-btn" id="zoomOut">-</button>
      </div>

      <div class="kill-feed" id="killFeed"></div>
    </div>

    <!-- Sidebar -->
    <div class="sidebar">
      <div class="minimap-container">
        <canvas id="minimapCanvas" width="196" height="196"></canvas>
      </div>

      <div class="panel">
        <div class="panel-title">Match Stats</div>
        <div class="stat-row">
          <span class="stat-label">Towers</span>
          <span><span class="stat-value blue" id="blueTowers">2</span> - <span class="stat-value red" id="redTowers">2</span></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Gold</span>
          <span><span class="stat-value blue" id="blueGold">0</span> - <span class="stat-value red" id="redGold">0</span></span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Minions</span>
          <span><span class="stat-value blue" id="blueMinions">0</span> - <span class="stat-value red" id="redMinions">0</span></span>
        </div>
      </div>

      <div class="panel">
        <div class="panel-title">Selected Unit</div>
        <div id="selectedInfo">
          <div class="stat-row">
            <span class="stat-label">Click a unit</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <div class="commentary-header">
        <span>üéôÔ∏è</span>
        <span>Live Commentary</span>
      </div>
      <div class="commentary-lines" id="commentaryLines"></div>
    </footer>
  </div>

  <script>
    // ============================================
    // GAME CONFIGURATION
    // ============================================
    const CONFIG = {
      // Map dimensions (game units)
      MAP_WIDTH: 12000,
      MAP_HEIGHT: 12000,

      // Lane runs diagonally from bottom-left to top-right
      LANE_START: { x: 1000, y: 11000 },  // Blue base (bottom-left)
      LANE_END: { x: 11000, y: 1000 },     // Red base (top-right)
      LANE_WIDTH: 600,

      // Tower positions along the lane (0 = blue base, 1 = red base)
      BLUE_TOWERS: [0.15, 0.30],  // Outer and inner
      RED_TOWERS: [0.85, 0.70],

      // Nexus positions
      BLUE_NEXUS: { x: 800, y: 11200 },
      RED_NEXUS: { x: 11200, y: 800 },

      // Spawning
      MINION_SPAWN_INTERVAL: 5000,  // 5 seconds

      // Combat
      TOWER_RANGE: 600,
      TOWER_DAMAGE: 150,
      CHAMPION_ATTACK_RANGE: 200,
      MINION_ATTACK_RANGE: 150,

      // Movement speeds (units per second)
      MINION_SPEED: 300,
      CHAMPION_SPEED: 400,

      // Stats
      MINION_HP: 300,
      MINION_DAMAGE: 20,
      TOWER_HP: 3000,
      NEXUS_HP: 5000,
    };

    // ============================================
    // GAME STATE
    // ============================================
    const gameState = {
      running: true,
      speed: 1,
      matchTime: 0,

      // Camera
      camera: {
        x: CONFIG.MAP_WIDTH / 2,
        y: CONFIG.MAP_HEIGHT / 2,
        zoom: 0.08,
        minZoom: 0.04,
        maxZoom: 0.2,
      },

      // Teams
      blueTeam: {
        kills: 0,
        gold: 0,
        minionsKilled: 0,
        towers: [],
        nexus: null,
        champions: [],
        minions: [],
      },
      redTeam: {
        kills: 0,
        gold: 0,
        minionsKilled: 0,
        towers: [],
        nexus: null,
        champions: [],
        minions: [],
      },

      // Kill feed entries
      killFeed: [],
      commentary: [],

      // Selection
      selectedUnit: null,

      // Timers
      lastMinionSpawn: { blue: 0, red: 0 },
    };

    // ============================================
    // ISOMETRIC PROJECTION
    // ============================================
    // Isometric angle (like LoL - roughly 30 degrees)
    const ISO_ANGLE = Math.PI / 6; // 30 degrees
    const ISO_COS = Math.cos(ISO_ANGLE);
    const ISO_SIN = Math.sin(ISO_ANGLE);

    // Convert world coordinates to isometric screen coordinates
    function worldToIso(x, y, z = 0) {
      // Standard isometric projection
      // X goes right-down, Y goes left-down
      const isoX = (x - y) * ISO_COS;
      const isoY = (x + y) * ISO_SIN - z;
      return { x: isoX, y: isoY };
    }

    // ============================================
    // UTILITY FUNCTIONS
    // ============================================
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function lerpPoint(p1, p2, t) {
      return {
        x: lerp(p1.x, p2.x, t),
        y: lerp(p1.y, p2.y, t),
      };
    }

    function distance(p1, p2) {
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function normalize(p1, p2) {
      const d = distance(p1, p2);
      if (d === 0) return { x: 0, y: 0 };
      return {
        x: (p2.x - p1.x) / d,
        y: (p2.y - p1.y) / d,
      };
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function formatGold(gold) {
      if (gold >= 1000) {
        return (gold / 1000).toFixed(1) + 'k';
      }
      return gold.toString();
    }

    // ============================================
    // UNIT CLASSES
    // ============================================
    class Unit {
      constructor(team, x, y) {
        this.team = team;
        this.x = x;
        this.y = y;
        this.targetX = x;
        this.targetY = y;
        this.hp = 100;
        this.maxHp = 100;
        this.damage = 10;
        this.attackRange = 100;
        this.attackCooldown = 1000;
        this.lastAttack = 0;
        this.speed = 300;
        this.dead = false;
        this.target = null;
      }

      takeDamage(amount, attacker) {
        this.hp -= amount;
        if (this.hp <= 0) {
          this.hp = 0;
          this.dead = true;
          this.onDeath(attacker);
        }
      }

      onDeath(killer) {}

      update(dt, now) {
        if (this.dead) return;

        // Find target if none
        if (!this.target || this.target.dead) {
          this.target = this.findTarget();
        }

        if (this.target) {
          const dist = distance(this, this.target);

          if (dist <= this.attackRange) {
            // Attack
            if (now - this.lastAttack >= this.attackCooldown) {
              this.attack(this.target);
              this.lastAttack = now;
            }
          } else {
            // Move toward target
            this.moveToward(this.target, dt);
          }
        } else {
          // No target, move down lane
          this.moveDownLane(dt);
        }
      }

      moveToward(target, dt) {
        const dir = normalize(this, target);
        this.x += dir.x * this.speed * dt;
        this.y += dir.y * this.speed * dt;
      }

      moveDownLane(dt) {
        // Override in subclass
      }

      attack(target) {
        target.takeDamage(this.damage, this);
      }

      findTarget() {
        return null;
      }
    }

    class Minion extends Unit {
      constructor(team, x, y) {
        super(team, x, y);
        this.hp = CONFIG.MINION_HP;
        this.maxHp = CONFIG.MINION_HP;
        this.damage = CONFIG.MINION_DAMAGE;
        this.attackRange = CONFIG.MINION_ATTACK_RANGE;
        this.attackCooldown = 1000;
        this.speed = CONFIG.MINION_SPEED;
        this.type = 'minion';
        this.goldValue = 20;
      }

      moveDownLane(dt) {
        const target = this.team === 'blue' ? CONFIG.LANE_END : CONFIG.LANE_START;
        const dir = normalize(this, target);
        this.x += dir.x * this.speed * dt;
        this.y += dir.y * this.speed * dt;
      }

      findTarget() {
        const enemies = this.team === 'blue' ?
          [...gameState.redTeam.minions, ...gameState.redTeam.champions] :
          [...gameState.blueTeam.minions, ...gameState.blueTeam.champions];

        // Also consider towers
        const enemyTowers = this.team === 'blue' ? gameState.redTeam.towers : gameState.blueTeam.towers;
        const allEnemies = [...enemies.filter(e => !e.dead), ...enemyTowers.filter(t => !t.dead)];

        let closest = null;
        let closestDist = Infinity;

        for (const enemy of allEnemies) {
          const d = distance(this, enemy);
          if (d < closestDist && d < 500) {
            closest = enemy;
            closestDist = d;
          }
        }

        return closest;
      }

      onDeath(killer) {
        if (killer && killer.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.gold += this.goldValue;
          team.minionsKilled++;
        }
      }
    }

    class Champion extends Unit {
      constructor(team, name, x, y) {
        super(team, x, y);
        this.name = name;
        this.hp = 800;
        this.maxHp = 800;
        this.mana = 300;
        this.maxMana = 300;
        this.level = 1;
        this.damage = 60;
        this.attackRange = CONFIG.CHAMPION_ATTACK_RANGE;
        this.attackCooldown = 800;
        this.speed = CONFIG.CHAMPION_SPEED;
        this.type = 'champion';
        this.respawnTime = 0;
        this.goldValue = 300;
        this.killValue = 300;
      }

      findTarget() {
        const enemies = this.team === 'blue' ?
          [...gameState.redTeam.minions, ...gameState.redTeam.champions] :
          [...gameState.blueTeam.minions, ...gameState.blueTeam.champions];

        let closest = null;
        let closestDist = Infinity;

        for (const enemy of enemies) {
          if (enemy.dead) continue;
          const d = distance(this, enemy);
          if (d < closestDist) {
            closest = enemy;
            closestDist = d;
          }
        }

        return closest;
      }

      moveDownLane(dt) {
        // Champions move toward center of map for fights
        const center = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, 0.5);
        const dist = distance(this, center);

        if (dist > 500) {
          const dir = normalize(this, center);
          this.x += dir.x * this.speed * dt;
          this.y += dir.y * this.speed * dt;
        }
      }

      onDeath(killer) {
        this.respawnTime = 10 + this.level * 2;

        if (killer && killer.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.kills++;
          team.gold += this.killValue;

          addKillFeedEntry(killer, this);
          addCommentary(`${killer.name || 'A minion'} takes down ${this.name}!`, 'kill');
        }
      }

      respawn() {
        const spawnPos = this.team === 'blue' ? CONFIG.LANE_START : CONFIG.LANE_END;
        this.x = spawnPos.x + (Math.random() - 0.5) * 200;
        this.y = spawnPos.y + (Math.random() - 0.5) * 200;
        this.hp = this.maxHp;
        this.mana = this.maxMana;
        this.dead = false;
        this.target = null;
      }
    }

    class Tower extends Unit {
      constructor(team, x, y, isOuter) {
        super(team, x, y);
        this.hp = CONFIG.TOWER_HP;
        this.maxHp = CONFIG.TOWER_HP;
        this.damage = CONFIG.TOWER_DAMAGE;
        this.attackRange = CONFIG.TOWER_RANGE;
        this.attackCooldown = 1000;
        this.type = 'tower';
        this.isOuter = isOuter;
        this.goldValue = 150;
      }

      moveToward() {} // Towers don't move
      moveDownLane() {}

      findTarget() {
        // Prioritize minions, then champions
        const enemyMinions = this.team === 'blue' ? gameState.redTeam.minions : gameState.blueTeam.minions;
        const enemyChampions = this.team === 'blue' ? gameState.redTeam.champions : gameState.blueTeam.champions;

        for (const minion of enemyMinions) {
          if (!minion.dead && distance(this, minion) <= this.attackRange) {
            return minion;
          }
        }

        for (const champ of enemyChampions) {
          if (!champ.dead && distance(this, champ) <= this.attackRange) {
            return champ;
          }
        }

        return null;
      }

      onDeath(killer) {
        if (killer && killer.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.gold += this.goldValue;

          addCommentary(`${this.team.toUpperCase()} ${this.isOuter ? 'outer' : 'inner'} tower destroyed!`, 'objective');
        }
      }

      update(dt, now) {
        if (this.dead) return;

        this.target = this.findTarget();

        if (this.target && now - this.lastAttack >= this.attackCooldown) {
          this.attack(this.target);
          this.lastAttack = now;
        }
      }
    }

    class Nexus extends Unit {
      constructor(team, x, y) {
        super(team, x, y);
        this.hp = CONFIG.NEXUS_HP;
        this.maxHp = CONFIG.NEXUS_HP;
        this.type = 'nexus';
      }

      moveToward() {}
      moveDownLane() {}
      findTarget() { return null; }
      update() {}

      onDeath() {
        const winner = this.team === 'blue' ? 'RED' : 'BLUE';
        addCommentary(`VICTORY! ${winner} team wins the game!`, 'objective');
        gameState.running = false;
      }
    }

    // ============================================
    // GAME INITIALIZATION
    // ============================================
    function initGame() {
      // Create Blue towers
      CONFIG.BLUE_TOWERS.forEach((t, i) => {
        const pos = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, t);
        gameState.blueTeam.towers.push(new Tower('blue', pos.x, pos.y, i === 0));
      });

      // Create Red towers
      CONFIG.RED_TOWERS.forEach((t, i) => {
        const pos = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, t);
        gameState.redTeam.towers.push(new Tower('red', pos.x, pos.y, i === 0));
      });

      // Create Nexuses
      gameState.blueTeam.nexus = new Nexus('blue', CONFIG.BLUE_NEXUS.x, CONFIG.BLUE_NEXUS.y);
      gameState.redTeam.nexus = new Nexus('red', CONFIG.RED_NEXUS.x, CONFIG.RED_NEXUS.y);

      // Create Champions
      const blueSpawn = CONFIG.LANE_START;
      const redSpawn = CONFIG.LANE_END;

      const blueChamps = ['Ironclad', 'Voltaic', 'Shadebow'];
      const redChamps = ['Ironclad', 'Voltaic', 'Shadebow'];

      blueChamps.forEach((name, i) => {
        const champ = new Champion('blue', name,
          blueSpawn.x + (i - 1) * 150,
          blueSpawn.y + (i - 1) * -150
        );
        gameState.blueTeam.champions.push(champ);
      });

      redChamps.forEach((name, i) => {
        const champ = new Champion('red', name,
          redSpawn.x + (i - 1) * -150,
          redSpawn.y + (i - 1) * 150
        );
        gameState.redTeam.champions.push(champ);
      });

      // Initial commentary
      addCommentary('Welcome to League of Molts! The match is about to begin.', 'objective');
      addCommentary('Minions will spawn shortly...', '');

      updateUI();
    }

    // ============================================
    // SPAWNING
    // ============================================
    function spawnMinion(team) {
      const spawn = team === 'blue' ? CONFIG.LANE_START : CONFIG.LANE_END;
      const offset = (Math.random() - 0.5) * 100;

      const minion = new Minion(team, spawn.x + offset, spawn.y + offset);

      if (team === 'blue') {
        gameState.blueTeam.minions.push(minion);
      } else {
        gameState.redTeam.minions.push(minion);
      }
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;

    function gameLoop(timestamp) {
      const dt = Math.min((timestamp - lastTime) / 1000, 0.1) * gameState.speed;
      lastTime = timestamp;

      if (gameState.running) {
        gameState.matchTime += dt;

        // Spawn minions every 5 seconds
        const now = gameState.matchTime * 1000;

        if (now - gameState.lastMinionSpawn.blue >= CONFIG.MINION_SPAWN_INTERVAL) {
          spawnMinion('blue');
          gameState.lastMinionSpawn.blue = now;
        }

        if (now - gameState.lastMinionSpawn.red >= CONFIG.MINION_SPAWN_INTERVAL) {
          spawnMinion('red');
          gameState.lastMinionSpawn.red = now;
        }

        // Update all units
        const allUnits = [
          ...gameState.blueTeam.towers,
          ...gameState.redTeam.towers,
          ...gameState.blueTeam.champions,
          ...gameState.redTeam.champions,
          ...gameState.blueTeam.minions,
          ...gameState.redTeam.minions,
        ];

        allUnits.forEach(unit => unit.update(dt, now));

        // Handle champion respawns
        [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(champ => {
          if (champ.dead && champ.respawnTime > 0) {
            champ.respawnTime -= dt;
            if (champ.respawnTime <= 0) {
              champ.respawn();
              addCommentary(`${champ.name} has respawned!`, '');
            }
          }
        });

        // Clean up dead minions
        gameState.blueTeam.minions = gameState.blueTeam.minions.filter(m => !m.dead);
        gameState.redTeam.minions = gameState.redTeam.minions.filter(m => !m.dead);

        updateUI();
      }

      render();
      requestAnimationFrame(gameLoop);
    }

    // ============================================
    // RENDERING
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimapCanvas');
    const minimapCtx = minimapCanvas.getContext('2d');

    function resizeCanvas() {
      const gameArea = document.getElementById('gameArea');
      canvas.width = gameArea.clientWidth;
      canvas.height = gameArea.clientHeight;
    }

    function worldToScreen(x, y, z = 0) {
      const { camera } = gameState;
      // First convert to isometric coordinates
      const iso = worldToIso(x - camera.x, y - camera.y, z);
      // Then apply zoom and center on screen
      return {
        x: iso.x * camera.zoom + canvas.width / 2,
        y: iso.y * camera.zoom + canvas.height / 2,
      };
    }

    function screenToWorld(sx, sy) {
      const { camera } = gameState;
      // Reverse the isometric projection
      const isoX = (sx - canvas.width / 2) / camera.zoom;
      const isoY = (sy - canvas.height / 2) / camera.zoom;

      // Inverse isometric transformation
      const worldX = (isoX / ISO_COS + isoY / ISO_SIN) / 2 + camera.x;
      const worldY = (isoY / ISO_SIN - isoX / ISO_COS) / 2 + camera.y;

      return { x: worldX, y: worldY };
    }

    function render() {
      ctx.fillStyle = '#1a1f2e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      renderGround();
      renderLane();
      renderJungle();

      // Depth sort all renderable objects (higher Y = render later = appears in front)
      const renderables = collectRenderables();
      renderables.sort((a, b) => (a.y + a.x) - (b.y + b.x));

      renderables.forEach(obj => {
        switch(obj.type) {
          case 'nexus': renderNexus(obj); break;
          case 'tower': renderTower(obj); break;
          case 'minion': renderMinion(obj); break;
          case 'champion': renderChampion(obj); break;
          case 'tree': renderTree(obj); break;
        }
      });

      renderMinimap();
    }

    function collectRenderables() {
      const objects = [];

      // Trees (generated once, cached)
      if (!gameState.trees) {
        gameState.trees = generateTrees();
      }
      objects.push(...gameState.trees);

      // Nexuses
      if (gameState.blueTeam.nexus && !gameState.blueTeam.nexus.dead) {
        objects.push({ ...gameState.blueTeam.nexus, type: 'nexus' });
      }
      if (gameState.redTeam.nexus && !gameState.redTeam.nexus.dead) {
        objects.push({ ...gameState.redTeam.nexus, type: 'nexus' });
      }

      // Towers
      [...gameState.blueTeam.towers, ...gameState.redTeam.towers]
        .filter(t => !t.dead)
        .forEach(t => objects.push({ ...t, type: 'tower' }));

      // Minions
      [...gameState.blueTeam.minions, ...gameState.redTeam.minions]
        .filter(m => !m.dead)
        .forEach(m => objects.push({ ...m, type: 'minion' }));

      // Champions
      [...gameState.blueTeam.champions, ...gameState.redTeam.champions]
        .forEach(c => objects.push({ ...c, type: 'champion' }));

      return objects;
    }

    function generateTrees() {
      const trees = [];
      const rng = mulberry32(12345); // Seeded RNG for consistent trees

      for (let i = 0; i < 150; i++) {
        const x = rng() * CONFIG.MAP_WIDTH;
        const y = rng() * CONFIG.MAP_HEIGHT;

        // Check distance from lane
        const distToLane = pointToLineDistance(
          { x, y },
          CONFIG.LANE_START,
          CONFIG.LANE_END
        );

        // Only place trees away from lane
        if (distToLane > 1200) {
          trees.push({
            x, y,
            type: 'tree',
            size: 60 + rng() * 40,
            variant: Math.floor(rng() * 3)
          });
        }
      }
      return trees;
    }

    // Seeded random number generator
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function pointToLineDistance(point, lineStart, lineEnd) {
      const A = point.x - lineStart.x;
      const B = point.y - lineStart.y;
      const C = lineEnd.x - lineStart.x;
      const D = lineEnd.y - lineStart.y;
      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;
      if (lenSq !== 0) param = dot / lenSq;

      let xx, yy;
      if (param < 0) { xx = lineStart.x; yy = lineStart.y; }
      else if (param > 1) { xx = lineEnd.x; yy = lineEnd.y; }
      else { xx = lineStart.x + param * C; yy = lineStart.y + param * D; }

      const dx = point.x - xx;
      const dy = point.y - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    function renderGround() {
      // Draw isometric ground tiles
      const tileSize = 400;
      const { camera } = gameState;

      ctx.strokeStyle = '#252d3d';
      ctx.lineWidth = 1;

      // Draw diamond grid
      for (let x = -tileSize; x <= CONFIG.MAP_WIDTH + tileSize; x += tileSize) {
        const start = worldToScreen(x, 0);
        const end = worldToScreen(x, CONFIG.MAP_HEIGHT);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      }
      for (let y = -tileSize; y <= CONFIG.MAP_HEIGHT + tileSize; y += tileSize) {
        const start = worldToScreen(0, y);
        const end = worldToScreen(CONFIG.MAP_WIDTH, y);
        ctx.beginPath();
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
        ctx.stroke();
      }
    }

    function renderLane() {
      const { camera } = gameState;

      // Draw lane as isometric path
      const lanePoints = [];
      const segments = 20;

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const point = lerpPoint(CONFIG.LANE_START, CONFIG.LANE_END, t);
        lanePoints.push(point);
      }

      // Lane width in isometric
      const laneWidth = CONFIG.LANE_WIDTH;

      // Calculate perpendicular direction for lane width
      const dir = normalize(CONFIG.LANE_START, CONFIG.LANE_END);
      const perp = { x: -dir.y, y: dir.x };

      // Draw lane surface
      ctx.fillStyle = '#2d3748';
      ctx.beginPath();

      // Top edge
      let firstPoint = true;
      for (const p of lanePoints) {
        const pos = worldToScreen(p.x + perp.x * laneWidth/2, p.y + perp.y * laneWidth/2);
        if (firstPoint) { ctx.moveTo(pos.x, pos.y); firstPoint = false; }
        else ctx.lineTo(pos.x, pos.y);
      }
      // Bottom edge (reverse)
      for (let i = lanePoints.length - 1; i >= 0; i--) {
        const p = lanePoints[i];
        const pos = worldToScreen(p.x - perp.x * laneWidth/2, p.y - perp.y * laneWidth/2);
        ctx.lineTo(pos.x, pos.y);
      }
      ctx.closePath();
      ctx.fill();

      // Lane border
      ctx.strokeStyle = '#4a5568';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Center line dashes
      ctx.strokeStyle = '#4a5568';
      ctx.lineWidth = 2;
      ctx.setLineDash([15, 10]);
      ctx.beginPath();
      const start = worldToScreen(CONFIG.LANE_START.x, CONFIG.LANE_START.y);
      const end = worldToScreen(CONFIG.LANE_END.x, CONFIG.LANE_END.y);
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function renderJungle() {
      // Jungle is rendered via depth-sorted trees in collectRenderables
    }

    function renderTree(tree) {
      const pos = worldToScreen(tree.x, tree.y);
      const baseSize = tree.size * gameState.camera.zoom;

      // Culling
      if (pos.x < -100 || pos.x > canvas.width + 100 ||
          pos.y < -100 || pos.y > canvas.height + 100) return;

      const height = baseSize * 1.5;

      // Shadow (isometric ellipse)
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y + baseSize * 0.1, baseSize * 0.5, baseSize * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();

      // Trunk
      ctx.fillStyle = '#4a3728';
      ctx.beginPath();
      ctx.moveTo(pos.x - baseSize * 0.1, pos.y);
      ctx.lineTo(pos.x - baseSize * 0.08, pos.y - height * 0.4);
      ctx.lineTo(pos.x + baseSize * 0.08, pos.y - height * 0.4);
      ctx.lineTo(pos.x + baseSize * 0.1, pos.y);
      ctx.fill();

      // Foliage layers (bottom to top for depth)
      const foliageColors = ['#1a472a', '#228b22', '#2d5a3a'];

      // Bottom layer
      ctx.fillStyle = foliageColors[0];
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y - height * 0.45, baseSize * 0.6, baseSize * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      // Middle layer
      ctx.fillStyle = foliageColors[1];
      ctx.beginPath();
      ctx.ellipse(pos.x - baseSize * 0.1, pos.y - height * 0.6, baseSize * 0.45, baseSize * 0.28, 0, 0, Math.PI * 2);
      ctx.fill();

      // Top layer
      ctx.fillStyle = foliageColors[2];
      ctx.beginPath();
      ctx.ellipse(pos.x + baseSize * 0.05, pos.y - height * 0.75, baseSize * 0.3, baseSize * 0.2, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    function renderNexus(nexus) {
      const pos = worldToScreen(nexus.x, nexus.y);
      const size = 100 * gameState.camera.zoom;
      const height = size * 0.8;

      const teamColor = nexus.team === 'blue' ?
        { dark: '#1a365d', mid: '#2b6cb0', light: '#4299e1', glow: '#63b3ed' } :
        { dark: '#742a2a', mid: '#c53030', light: '#fc8181', glow: '#feb2b2' };

      // Glow effect
      const gradient = ctx.createRadialGradient(pos.x, pos.y - height/2, 0, pos.x, pos.y - height/2, size * 1.5);
      gradient.addColorStop(0, teamColor.glow + '40');
      gradient.addColorStop(1, 'transparent');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y - height/2, size * 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Base platform (isometric diamond)
      ctx.fillStyle = teamColor.dark;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - size * 0.3);
      ctx.lineTo(pos.x + size * 0.8, pos.y);
      ctx.lineTo(pos.x, pos.y + size * 0.3);
      ctx.lineTo(pos.x - size * 0.8, pos.y);
      ctx.closePath();
      ctx.fill();

      // Crystal structure (3D hexagonal prism)
      // Left face
      ctx.fillStyle = teamColor.dark;
      ctx.beginPath();
      ctx.moveTo(pos.x - size * 0.3, pos.y);
      ctx.lineTo(pos.x - size * 0.3, pos.y - height);
      ctx.lineTo(pos.x, pos.y - height - size * 0.2);
      ctx.lineTo(pos.x, pos.y - size * 0.15);
      ctx.closePath();
      ctx.fill();

      // Right face
      ctx.fillStyle = teamColor.mid;
      ctx.beginPath();
      ctx.moveTo(pos.x + size * 0.3, pos.y);
      ctx.lineTo(pos.x + size * 0.3, pos.y - height);
      ctx.lineTo(pos.x, pos.y - height - size * 0.2);
      ctx.lineTo(pos.x, pos.y - size * 0.15);
      ctx.closePath();
      ctx.fill();

      // Top face
      ctx.fillStyle = teamColor.light;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - height - size * 0.2);
      ctx.lineTo(pos.x - size * 0.3, pos.y - height);
      ctx.lineTo(pos.x, pos.y - height + size * 0.1);
      ctx.lineTo(pos.x + size * 0.3, pos.y - height);
      ctx.closePath();
      ctx.fill();

      // Health bar
      renderHealthBar(pos.x, pos.y - height - size * 0.5, nexus.hp, nexus.maxHp, size * 1.5);
    }

    function renderTower(tower) {
      const pos = worldToScreen(tower.x, tower.y);
      const size = 50 * gameState.camera.zoom;
      const height = size * 2;

      const teamColor = tower.team === 'blue' ?
        { dark: '#1a365d', mid: '#2b6cb0', light: '#4299e1' } :
        { dark: '#742a2a', mid: '#c53030', light: '#fc8181' };

      // Range indicator (isometric circle = ellipse)
      if (tower.target) {
        ctx.strokeStyle = tower.team === 'blue' ? '#4299e130' : '#fc818130';
        ctx.lineWidth = 2;
        ctx.beginPath();
        const rangeScale = CONFIG.TOWER_RANGE * gameState.camera.zoom;
        ctx.ellipse(pos.x, pos.y, rangeScale * ISO_COS, rangeScale * ISO_SIN, 0, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y + size * 0.2, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Base (isometric)
      ctx.fillStyle = teamColor.dark;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - size * 0.2);
      ctx.lineTo(pos.x + size * 0.5, pos.y);
      ctx.lineTo(pos.x, pos.y + size * 0.2);
      ctx.lineTo(pos.x - size * 0.5, pos.y);
      ctx.closePath();
      ctx.fill();

      // Tower body (left side)
      ctx.fillStyle = teamColor.dark;
      ctx.beginPath();
      ctx.moveTo(pos.x - size * 0.2, pos.y);
      ctx.lineTo(pos.x - size * 0.15, pos.y - height);
      ctx.lineTo(pos.x, pos.y - height);
      ctx.lineTo(pos.x, pos.y - size * 0.1);
      ctx.closePath();
      ctx.fill();

      // Tower body (right side)
      ctx.fillStyle = teamColor.mid;
      ctx.beginPath();
      ctx.moveTo(pos.x + size * 0.2, pos.y);
      ctx.lineTo(pos.x + size * 0.15, pos.y - height);
      ctx.lineTo(pos.x, pos.y - height);
      ctx.lineTo(pos.x, pos.y - size * 0.1);
      ctx.closePath();
      ctx.fill();

      // Tower top (pointed)
      ctx.fillStyle = teamColor.light;
      ctx.beginPath();
      ctx.moveTo(pos.x, pos.y - height - size * 0.4);
      ctx.lineTo(pos.x - size * 0.2, pos.y - height);
      ctx.lineTo(pos.x + size * 0.2, pos.y - height);
      ctx.closePath();
      ctx.fill();

      // Attack beam
      if (tower.target && !tower.target.dead) {
        const targetPos = worldToScreen(tower.target.x, tower.target.y);
        ctx.strokeStyle = tower.team === 'blue' ? '#4299e1' : '#fc8181';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y - height);
        ctx.lineTo(targetPos.x, targetPos.y - 20 * gameState.camera.zoom);
        ctx.stroke();

        // Impact effect
        ctx.fillStyle = tower.team === 'blue' ? '#63b3ed' : '#feb2b2';
        ctx.beginPath();
        ctx.arc(targetPos.x, targetPos.y - 20 * gameState.camera.zoom, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Health bar
      renderHealthBar(pos.x, pos.y - height - size * 0.6, tower.hp, tower.maxHp, size * 1.8);
    }

    function renderMinion(minion) {
      const pos = worldToScreen(minion.x, minion.y);
      const size = 18 * gameState.camera.zoom;

      const teamColor = minion.team === 'blue' ?
        { body: '#63b3ed', outline: '#2b6cb0' } :
        { body: '#fc8181', outline: '#c53030' };

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.25)';
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y + size * 0.3, size * 0.6, size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body (isometric blob)
      ctx.fillStyle = teamColor.body;
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y - size * 0.3, size * 0.7, size * 0.5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Outline
      ctx.strokeStyle = teamColor.outline;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Eyes (simple dots)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(pos.x - size * 0.2, pos.y - size * 0.4, size * 0.12, 0, Math.PI * 2);
      ctx.arc(pos.x + size * 0.2, pos.y - size * 0.4, size * 0.12, 0, Math.PI * 2);
      ctx.fill();

      // Health bar when damaged
      if (minion.hp < minion.maxHp) {
        renderHealthBar(pos.x, pos.y - size * 1.2, minion.hp, minion.maxHp, size * 2, true);
      }
    }

    function renderChampion(champ) {
      const pos = worldToScreen(champ.x, champ.y);
      const size = 32 * gameState.camera.zoom;

      const teamColor = champ.team === 'blue' ?
        { dark: '#1a365d', mid: '#2b6cb0', light: '#4299e1', glow: '#63b3ed' } :
        { dark: '#742a2a', mid: '#c53030', light: '#fc8181', glow: '#feb2b2' };

      if (champ.dead) {
        // Death marker
        ctx.fillStyle = 'rgba(100,100,100,0.4)';
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y, size * 0.5, size * 0.25, 0, 0, Math.PI * 2);
        ctx.fill();

        // Skull or X marker
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(pos.x - size * 0.2, pos.y - size * 0.1);
        ctx.lineTo(pos.x + size * 0.2, pos.y + size * 0.1);
        ctx.moveTo(pos.x + size * 0.2, pos.y - size * 0.1);
        ctx.lineTo(pos.x - size * 0.2, pos.y + size * 0.1);
        ctx.stroke();

        // Respawn timer
        if (champ.respawnTime > 0) {
          ctx.fillStyle = '#fff';
          ctx.font = `bold ${14 * gameState.camera.zoom / 0.08}px sans-serif`;
          ctx.textAlign = 'center';
          ctx.fillText(Math.ceil(champ.respawnTime) + 's', pos.x, pos.y - size * 0.5);
        }
        return;
      }

      // Selection ring
      if (gameState.selectedUnit === champ) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.ellipse(pos.x, pos.y + size * 0.1, size * 1.1, size * 0.55, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y + size * 0.15, size * 0.7, size * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body (isometric capsule shape)
      const bodyHeight = size * 1.2;

      // Body base
      ctx.fillStyle = teamColor.mid;
      ctx.beginPath();
      ctx.ellipse(pos.x, pos.y - size * 0.1, size * 0.5, size * 0.35, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body middle
      ctx.fillStyle = teamColor.mid;
      ctx.fillRect(pos.x - size * 0.5, pos.y - bodyHeight * 0.6, size, bodyHeight * 0.5);

      // Head
      ctx.fillStyle = teamColor.light;
      ctx.beginPath();
      ctx.arc(pos.x, pos.y - bodyHeight * 0.7, size * 0.35, 0, Math.PI * 2);
      ctx.fill();

      // Champion initial on body
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${size * 0.6}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(champ.name[0], pos.x, pos.y - size * 0.3);

      // Level badge
      const badgeX = pos.x + size * 0.6;
      const badgeY = pos.y - size * 0.2;
      ctx.fillStyle = '#1a202c';
      ctx.beginPath();
      ctx.arc(badgeX, badgeY, size * 0.28, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#f6e05e';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.fillStyle = '#f6e05e';
      ctx.font = `bold ${size * 0.3}px sans-serif`;
      ctx.fillText(champ.level, badgeX, badgeY);

      // Health bar
      renderHealthBar(pos.x, pos.y - bodyHeight - size * 0.2, champ.hp, champ.maxHp, size * 2.2);

      // Mana bar (smaller, below health)
      renderManaBar(pos.x, pos.y - bodyHeight - size * 0.05, champ.mana, champ.maxMana, size * 2.2);
    }

    function renderHealthBar(x, y, hp, maxHp, width, small = false) {
      const height = small ? 4 : 6;
      const hpPercent = Math.max(0, hp / maxHp);

      // Background
      ctx.fillStyle = '#1a202c';
      ctx.fillRect(x - width / 2, y, width, height);

      // Health
      let color = '#48bb78'; // green
      if (hpPercent < 0.3) color = '#fc8181'; // red
      else if (hpPercent < 0.6) color = '#f6e05e'; // yellow

      ctx.fillStyle = color;
      ctx.fillRect(x - width / 2 + 1, y + 1, (width - 2) * hpPercent, height - 2);

      // Border
      ctx.strokeStyle = '#2d3748';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - width / 2, y, width, height);
    }

    function renderManaBar(x, y, mana, maxMana, width) {
      const height = 3;
      const manaPercent = Math.max(0, mana / maxMana);

      ctx.fillStyle = '#1a202c';
      ctx.fillRect(x - width / 2, y, width, height);

      ctx.fillStyle = '#4299e1';
      ctx.fillRect(x - width / 2 + 1, y + 1, (width - 2) * manaPercent, height - 2);
    }

    function renderMinimap() {
      const w = minimapCanvas.width;
      const h = minimapCanvas.height;

      // Background
      minimapCtx.fillStyle = '#1a202c';
      minimapCtx.fillRect(0, 0, w, h);

      // The minimap shows an isometric view rotated so the lane goes diagonal
      // Transform world coords to minimap coords (isometric projection)
      function minimapPos(worldX, worldY) {
        // Normalize to 0-1 range
        const nx = worldX / CONFIG.MAP_WIDTH;
        const ny = worldY / CONFIG.MAP_HEIGHT;

        // Apply isometric transform for minimap
        const isoX = (nx - ny) * 0.5 + 0.5;
        const isoY = (nx + ny) * 0.35 + 0.15;

        return {
          x: isoX * w,
          y: isoY * h
        };
      }

      // Draw map boundary (diamond shape)
      minimapCtx.strokeStyle = '#2d3748';
      minimapCtx.lineWidth = 2;
      minimapCtx.beginPath();
      const corners = [
        minimapPos(0, 0),
        minimapPos(CONFIG.MAP_WIDTH, 0),
        minimapPos(CONFIG.MAP_WIDTH, CONFIG.MAP_HEIGHT),
        minimapPos(0, CONFIG.MAP_HEIGHT),
      ];
      minimapCtx.moveTo(corners[0].x, corners[0].y);
      corners.forEach(c => minimapCtx.lineTo(c.x, c.y));
      minimapCtx.closePath();
      minimapCtx.stroke();

      // Lane
      const laneStart = minimapPos(CONFIG.LANE_START.x, CONFIG.LANE_START.y);
      const laneEnd = minimapPos(CONFIG.LANE_END.x, CONFIG.LANE_END.y);

      minimapCtx.strokeStyle = '#4a5568';
      minimapCtx.lineWidth = 6;
      minimapCtx.lineCap = 'round';
      minimapCtx.beginPath();
      minimapCtx.moveTo(laneStart.x, laneStart.y);
      minimapCtx.lineTo(laneEnd.x, laneEnd.y);
      minimapCtx.stroke();

      // Nexuses
      const blueNexusPos = minimapPos(CONFIG.BLUE_NEXUS.x, CONFIG.BLUE_NEXUS.y);
      const redNexusPos = minimapPos(CONFIG.RED_NEXUS.x, CONFIG.RED_NEXUS.y);

      minimapCtx.fillStyle = '#4299e1';
      minimapCtx.beginPath();
      minimapCtx.arc(blueNexusPos.x, blueNexusPos.y, 8, 0, Math.PI * 2);
      minimapCtx.fill();

      minimapCtx.fillStyle = '#fc8181';
      minimapCtx.beginPath();
      minimapCtx.arc(redNexusPos.x, redNexusPos.y, 8, 0, Math.PI * 2);
      minimapCtx.fill();

      // Towers
      [...gameState.blueTeam.towers, ...gameState.redTeam.towers].forEach(tower => {
        if (tower.dead) return;
        const pos = minimapPos(tower.x, tower.y);
        minimapCtx.fillStyle = tower.team === 'blue' ? '#2b6cb0' : '#c53030';
        minimapCtx.fillRect(pos.x - 4, pos.y - 4, 8, 8);
      });

      // Champions
      [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(champ => {
        if (champ.dead) return;
        const pos = minimapPos(champ.x, champ.y);
        minimapCtx.fillStyle = champ.team === 'blue' ? '#63b3ed' : '#fc8181';
        minimapCtx.strokeStyle = '#fff';
        minimapCtx.lineWidth = 1.5;
        minimapCtx.beginPath();
        minimapCtx.arc(pos.x, pos.y, 5, 0, Math.PI * 2);
        minimapCtx.fill();
        minimapCtx.stroke();
      });

      // Minions (small dots)
      [...gameState.blueTeam.minions, ...gameState.redTeam.minions].forEach(minion => {
        const pos = minimapPos(minion.x, minion.y);
        minimapCtx.fillStyle = minion.team === 'blue' ? '#90cdf4' : '#feb2b2';
        minimapCtx.beginPath();
        minimapCtx.arc(pos.x, pos.y, 2, 0, Math.PI * 2);
        minimapCtx.fill();
      });

      // Camera viewport indicator
      const { camera } = gameState;
      const vpCenter = minimapPos(camera.x, camera.y);

      minimapCtx.strokeStyle = '#ffffff60';
      minimapCtx.lineWidth = 1;
      minimapCtx.beginPath();
      minimapCtx.arc(vpCenter.x, vpCenter.y, 15, 0, Math.PI * 2);
      minimapCtx.stroke();
    }

    // ============================================
    // UI UPDATES
    // ============================================
    function updateUI() {
      // Match time
      document.getElementById('matchTime').textContent = formatTime(gameState.matchTime);

      // Scores
      document.getElementById('blueKills').textContent = gameState.blueTeam.kills;
      document.getElementById('redKills').textContent = gameState.redTeam.kills;

      // Stats
      document.getElementById('blueTowers').textContent = gameState.blueTeam.towers.filter(t => !t.dead).length;
      document.getElementById('redTowers').textContent = gameState.redTeam.towers.filter(t => !t.dead).length;
      document.getElementById('blueGold').textContent = formatGold(gameState.blueTeam.gold);
      document.getElementById('redGold').textContent = formatGold(gameState.redTeam.gold);
      document.getElementById('blueMinions').textContent = gameState.blueTeam.minionsKilled;
      document.getElementById('redMinions').textContent = gameState.redTeam.minionsKilled;

      // Champion portraits
      updateChampionPortraits();

      // Zoom level
      document.getElementById('zoomLevel').textContent = Math.round(gameState.camera.zoom * 100 / 0.08) + '%';
    }

    function updateChampionPortraits() {
      const blueContainer = document.getElementById('blueChampions');
      const redContainer = document.getElementById('redChampions');

      blueContainer.innerHTML = gameState.blueTeam.champions.map(champ => `
        <div class="portrait blue ${champ.dead ? 'dead' : ''}">
          ${champ.name[0]}
          <span class="level">${champ.level}</span>
          <div class="hp-bar-container">
            <div class="hp-bar" style="width: ${(champ.hp / champ.maxHp) * 100}%"></div>
          </div>
        </div>
      `).join('');

      redContainer.innerHTML = gameState.redTeam.champions.map(champ => `
        <div class="portrait red ${champ.dead ? 'dead' : ''}">
          ${champ.name[0]}
          <span class="level">${champ.level}</span>
          <div class="hp-bar-container">
            <div class="hp-bar" style="width: ${(champ.hp / champ.maxHp) * 100}%"></div>
          </div>
        </div>
      `).join('');
    }

    function addKillFeedEntry(killer, victim) {
      const entry = {
        killer: killer.name || 'Minion',
        killerTeam: killer.team,
        victim: victim.name || 'Minion',
        victimTeam: victim.team,
        timestamp: gameState.matchTime,
      };

      gameState.killFeed.unshift(entry);
      if (gameState.killFeed.length > 5) gameState.killFeed.pop();

      const killFeed = document.getElementById('killFeed');
      killFeed.innerHTML = gameState.killFeed.map(e => `
        <div class="kill-entry ${e.killerTeam}">
          <span class="killer ${e.killerTeam}">${e.killer}</span>
          <span class="icon">‚öî</span>
          <span class="victim ${e.victimTeam}">${e.victim}</span>
        </div>
      `).join('');
    }

    function addCommentary(text, type = '') {
      gameState.commentary.unshift({ text, type, timestamp: gameState.matchTime });
      if (gameState.commentary.length > 10) gameState.commentary.pop();

      const container = document.getElementById('commentaryLines');
      container.innerHTML = gameState.commentary.map(c => `
        <div class="commentary-line ${c.type}">${c.text}</div>
      `).join('');
    }

    // ============================================
    // INPUT HANDLING
    // ============================================
    function setupInput() {
      const gameArea = document.getElementById('gameArea');

      // Zoom with scroll
      gameArea.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
        gameState.camera.zoom = Math.max(
          gameState.camera.minZoom,
          Math.min(gameState.camera.maxZoom, gameState.camera.zoom * zoomDelta)
        );
        updateUI();
      });

      // Pan with drag
      let isDragging = false;
      let lastMouseX, lastMouseY;

      gameArea.addEventListener('mousedown', (e) => {
        if (e.button === 0) {
          isDragging = true;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });

      window.addEventListener('mousemove', (e) => {
        if (isDragging) {
          const dx = e.clientX - lastMouseX;
          const dy = e.clientY - lastMouseY;
          gameState.camera.x -= dx / gameState.camera.zoom;
          gameState.camera.y -= dy / gameState.camera.zoom;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });

      window.addEventListener('mouseup', () => {
        isDragging = false;
      });

      // Click to select
      canvas.addEventListener('click', (e) => {
        if (isDragging) return;

        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const world = screenToWorld(screenX, screenY);

        // Find clicked unit
        const allUnits = [
          ...gameState.blueTeam.champions,
          ...gameState.redTeam.champions,
        ];

        let clicked = null;
        let closestDist = 50 / gameState.camera.zoom;

        for (const unit of allUnits) {
          if (unit.dead) continue;
          const d = distance(world, unit);
          if (d < closestDist) {
            clicked = unit;
            closestDist = d;
          }
        }

        gameState.selectedUnit = clicked;
        updateSelectedInfo();
      });

      // Minimap click to move camera
      minimapCanvas.addEventListener('click', (e) => {
        const rect = minimapCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / minimapCanvas.width * CONFIG.MAP_WIDTH;
        const y = (e.clientY - rect.top) / minimapCanvas.height * CONFIG.MAP_HEIGHT;
        gameState.camera.x = x;
        gameState.camera.y = y;
      });

      // Zoom buttons
      document.getElementById('zoomIn').addEventListener('click', () => {
        gameState.camera.zoom = Math.min(gameState.camera.maxZoom, gameState.camera.zoom * 1.2);
        updateUI();
      });

      document.getElementById('zoomOut').addEventListener('click', () => {
        gameState.camera.zoom = Math.max(gameState.camera.minZoom, gameState.camera.zoom / 1.2);
        updateUI();
      });

      // Demo controls
      document.getElementById('playPauseBtn').addEventListener('click', (e) => {
        gameState.running = !gameState.running;
        e.target.textContent = gameState.running ? 'Pause' : 'Play';
        e.target.classList.toggle('active', gameState.running);
      });

      document.getElementById('speedBtn').addEventListener('click', (e) => {
        const speeds = [1, 2, 4, 0.5];
        const currentIndex = speeds.indexOf(gameState.speed);
        gameState.speed = speeds[(currentIndex + 1) % speeds.length];
        e.target.textContent = gameState.speed + 'x';
      });

      document.getElementById('resetBtn').addEventListener('click', () => {
        location.reload();
      });

      // Window resize
      window.addEventListener('resize', resizeCanvas);
    }

    function updateSelectedInfo() {
      const container = document.getElementById('selectedInfo');
      const unit = gameState.selectedUnit;

      if (!unit) {
        container.innerHTML = '<div class="stat-row"><span class="stat-label">Click a champion</span></div>';
        return;
      }

      container.innerHTML = `
        <div class="stat-row">
          <span class="stat-label">Name</span>
          <span class="stat-value">${unit.name}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Team</span>
          <span class="stat-value ${unit.team}">${unit.team.toUpperCase()}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">HP</span>
          <span class="stat-value">${Math.round(unit.hp)}/${unit.maxHp}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Level</span>
          <span class="stat-value">${unit.level}</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Damage</span>
          <span class="stat-value">${unit.damage}</span>
        </div>
      `;
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    resizeCanvas();
    setupInput();
    initGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
