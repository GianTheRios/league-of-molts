<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>League of Molts - Demo Mode</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0d0d0d;
      color: #d4c4a8;
      font-family: 'Cinzel', 'Times New Roman', serif;
      overflow: hidden;
    }

    .container {
      display: grid;
      grid-template-rows: 60px 1fr 90px;
      grid-template-columns: 1fr 240px;
      height: 100vh;
    }

    /* Header - Dark Fantasy Style */
    .header {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, #1a1612 0%, #0d0b09 100%);
      border-bottom: 2px solid #3d2f1f;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 20px;
      z-index: 100;
    }

    .team-section {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .team-label {
      font-size: 10px;
      font-weight: bold;
      letter-spacing: 3px;
      text-transform: uppercase;
    }

    .team-label.blue { color: #6b9ac4; }
    .team-label.red { color: #c45c5c; }

    .champions { display: flex; gap: 6px; }

    .portrait {
      width: 42px;
      height: 42px;
      border-radius: 4px;
      border: 2px solid;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      font-weight: bold;
      font-size: 14px;
    }

    .portrait.blue {
      border-color: #4a7a9c;
      background: linear-gradient(135deg, #1a2a3a 0%, #0d1520 100%);
      color: #8ab4d4;
      box-shadow: 0 0 10px rgba(74, 122, 156, 0.3);
    }
    .portrait.red {
      border-color: #9c4a4a;
      background: linear-gradient(135deg, #3a1a1a 0%, #200d0d 100%);
      color: #d48a8a;
      box-shadow: 0 0 10px rgba(156, 74, 74, 0.3);
    }
    .portrait.dead { opacity: 0.4; }

    .portrait .level {
      position: absolute;
      bottom: -4px;
      right: -4px;
      background: #1a1612;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      color: #d4a74a;
      border: 1px solid #3d2f1f;
    }

    .portrait .bars {
      position: absolute;
      bottom: 2px;
      left: 2px;
      right: 2px;
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .portrait .hp-bar, .portrait .mp-bar {
      height: 3px;
      background: #1a1a1a;
      border-radius: 1px;
      overflow: hidden;
    }

    .portrait .hp-bar .fill { height: 100%; background: linear-gradient(90deg, #8b4513, #a0522d); }
    .portrait .mp-bar .fill { height: 100%; background: linear-gradient(90deg, #2f4f4f, #4a7a7a); }

    .center-section {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .demo-label {
      font-size: 10px;
      color: #5a4a3a;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .match-time {
      font-size: 24px;
      font-weight: bold;
      font-family: monospace;
      color: #d4c4a8;
      text-shadow: 0 0 10px rgba(212, 167, 74, 0.3);
    }

    .score {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 16px;
      font-weight: bold;
    }

    .score .blue { color: #6b9ac4; }
    .score .red { color: #c45c5c; }
    .score .divider { color: #3d2f1f; }

    /* Game Area - Dark Fantasy */
    .game-area {
      background: radial-gradient(ellipse at center, #1a1612 0%, #0d0b09 60%, #050404 100%);
      position: relative;
      overflow: hidden;
    }

    #gameSvg {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Controls */
    .demo-controls {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      gap: 6px;
      z-index: 50;
    }

    .demo-btn {
      padding: 8px 14px;
      background: linear-gradient(180deg, #2a2218 0%, #1a1612 100%);
      border: 1px solid #3d2f1f;
      border-radius: 4px;
      color: #d4c4a8;
      font-size: 11px;
      cursor: pointer;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .demo-btn:hover { background: #3a2f22; border-color: #5a4a3a; }
    .demo-btn.active { background: #4a3a2a; border-color: #d4a74a; color: #d4a74a; }

    .zoom-controls {
      position: absolute;
      bottom: 16px;
      right: 260px;
      display: flex;
      gap: 4px;
      z-index: 50;
    }

    .zoom-btn {
      width: 30px;
      height: 30px;
      background: linear-gradient(180deg, #2a2218 0%, #1a1612 100%);
      border: 1px solid #3d2f1f;
      border-radius: 4px;
      color: #d4c4a8;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .zoom-btn:hover { background: #3a2f22; border-color: #5a4a3a; }

    /* Sidebar - Dark Fantasy */
    .sidebar {
      background: linear-gradient(180deg, #1a1612 0%, #0d0b09 100%);
      border-left: 2px solid #3d2f1f;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
    }

    .minimap-container {
      background: #0d0b09;
      border-radius: 4px;
      padding: 6px;
      border: 1px solid #3d2f1f;
    }

    #minimapSvg { display: block; border-radius: 4px; }

    .panel {
      background: linear-gradient(180deg, #1a1612 0%, #12100d 100%);
      border-radius: 4px;
      padding: 10px;
      border: 1px solid #3d2f1f;
    }

    .panel-title {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin-bottom: 8px;
    }

    .panel-title.blue { color: #6b9ac4; }
    .panel-title.red { color: #c45c5c; }

    .champ-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 0;
      border-bottom: 1px solid #2a2218;
    }

    .champ-row:last-child { border-bottom: none; }

    .champ-icon {
      width: 26px;
      height: 26px;
      border-radius: 3px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: bold;
    }

    .champ-icon.blue { background: #1a2a3a; border: 2px solid #4a7a9c; color: #8ab4d4; }
    .champ-icon.red { background: #3a1a1a; border: 2px solid #9c4a4a; color: #d48a8a; }

    .champ-details { flex: 1; }
    .champ-name { font-size: 11px; font-weight: 500; color: #d4c4a8; }
    .champ-level { font-size: 9px; color: #5a4a3a; }

    .champ-hp-bar {
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      margin-top: 3px;
      overflow: hidden;
    }

    .champ-hp-bar .fill { height: 100%; background: linear-gradient(90deg, #8b4513, #a0522d); border-radius: 2px; }

    /* Footer - Commentary */
    .footer {
      grid-column: 1 / -1;
      background: linear-gradient(180deg, #12100d 0%, #0d0b09 100%);
      border-top: 2px solid #3d2f1f;
      display: flex;
      flex-direction: column;
    }

    .commentary-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 16px;
      border-bottom: 1px solid #2a2218;
      font-size: 10px;
      color: #5a4a3a;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .commentary-lines {
      flex: 1;
      overflow-y: auto;
      padding: 6px 16px;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .commentary-line {
      color: #8a7a6a;
      font-size: 12px;
      line-height: 1.4;
    }

    .commentary-line.kill { color: #c45c5c; font-weight: 500; }
    .commentary-line.objective { color: #d4a74a; font-weight: 500; }
  </style>
</head>
<body>
  <div class="container">
    <header class="header">
      <div class="team-section">
        <div class="team-label blue">Blue</div>
        <div class="champions" id="bluePortraits"></div>
      </div>

      <div class="center-section">
        <div class="score">
          <span class="blue" id="blueKills">0</span>
          <span class="divider">-</span>
          <span class="red" id="redKills">0</span>
        </div>
        <div class="match-time" id="matchTime">0:00</div>
        <div class="demo-label">Demo Mode</div>
      </div>

      <div class="team-section">
        <div class="champions" id="redPortraits"></div>
        <div class="team-label red">Red</div>
      </div>
    </header>

    <div class="game-area" id="gameArea">
      <svg id="gameSvg" preserveAspectRatio="xMidYMid meet">
        <defs>
          <!-- Dark Fantasy Gradients -->
          <linearGradient id="groundGrad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#1a1815"/>
            <stop offset="50%" style="stop-color:#12100d"/>
            <stop offset="100%" style="stop-color:#1a1815"/>
          </linearGradient>
          <linearGradient id="laneGrad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#2a2520"/>
            <stop offset="50%" style="stop-color:#3a3530"/>
            <stop offset="100%" style="stop-color:#2a2520"/>
          </linearGradient>
          <linearGradient id="blueGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#5a8aaa"/>
            <stop offset="100%" style="stop-color:#3a5a7a"/>
          </linearGradient>
          <linearGradient id="redGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#aa5a5a"/>
            <stop offset="100%" style="stop-color:#7a3a3a"/>
          </linearGradient>
          <linearGradient id="stoneGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#5a5550"/>
            <stop offset="100%" style="stop-color:#3a3530"/>
          </linearGradient>
          <linearGradient id="goldGrad" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color:#d4a74a"/>
            <stop offset="100%" style="stop-color:#8b6914"/>
          </linearGradient>

          <!-- Glow Effects -->
          <filter id="blueGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
          <filter id="redGlow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
          <filter id="shadow">
            <feDropShadow dx="2" dy="4" stdDeviation="3" flood-opacity="0.6"/>
          </filter>

          <!-- Stone Texture Pattern -->
          <pattern id="stonePattern" patternUnits="userSpaceOnUse" width="20" height="20">
            <rect width="20" height="20" fill="#2a2520"/>
            <circle cx="5" cy="5" r="1" fill="#3a3530" opacity="0.5"/>
            <circle cx="15" cy="12" r="1.5" fill="#1a1815" opacity="0.3"/>
            <circle cx="8" cy="18" r="1" fill="#3a3530" opacity="0.4"/>
          </pattern>
        </defs>
        <g id="worldGroup">
          <g id="groundLayer"></g>
          <g id="laneLayer"></g>
          <g id="effectsLayer"></g>
          <g id="unitsLayer"></g>
        </g>
      </svg>

      <div class="demo-controls">
        <button class="demo-btn active" id="playPauseBtn">Pause</button>
        <button class="demo-btn" id="speedBtn">1x</button>
        <button class="demo-btn" id="resetBtn">Reset</button>
      </div>

      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomInBtn">+</button>
        <button class="zoom-btn" id="zoomOutBtn">-</button>
      </div>
    </div>

    <div class="sidebar">
      <div class="minimap-container">
        <svg id="minimapSvg" width="220" height="130" viewBox="0 0 220 130"></svg>
      </div>
      <div class="panel">
        <div class="panel-title blue">Blue Covenant</div>
        <div id="blueTeamPanel"></div>
      </div>
      <div class="panel">
        <div class="panel-title red">Red Covenant</div>
        <div id="redTeamPanel"></div>
      </div>
    </div>

    <footer class="footer">
      <div class="commentary-header">Chronicle</div>
      <div class="commentary-lines" id="commentaryLines"></div>
    </footer>
  </div>

  <script>
    // =============================================
    // CONFIGURATION - Base-centric layout
    // =============================================
    const CONFIG = {
      // World dimensions - very large for long lane with tower spacing
      WORLD_W: 3600,
      WORLD_H: 2000,

      // Ground plane - big isometric diamond
      GROUND: { cx: 1800, cy: 1000, width: 3200, height: 1700 },

      // BASE CENTERS - large fortress areas, far apart
      BLUE_BASE: { x: 350, y: 1600 },
      RED_BASE: { x: 3250, y: 400 },
      BASE_RADIUS: 200,  // Large fortress bases

      // Lane properties - wide and robust
      LANE_WIDTH: 140,

      // Tower positions - even spacing along lane
      // 15% from base to first tower, 20% between towers, 30% middle gap
      BLUE_TOWERS: [0.15, 0.35],
      RED_TOWERS: [0.65, 0.85],

      // Combat
      TOWER_RANGE: 140,
      ATTACK_RANGE: 70,
      MINION_SPAWN_INTERVAL: 5000,

      // Speeds
      MINION_SPEED: 80,
      CHAMPION_SPEED: 110,
    };

    // Compute lane direction and derived properties
    (function computeLaneProperties() {
      const dx = CONFIG.RED_BASE.x - CONFIG.BLUE_BASE.x;
      const dy = CONFIG.RED_BASE.y - CONFIG.BLUE_BASE.y;
      const len = Math.sqrt(dx * dx + dy * dy);

      // Normalized lane direction vector (blue -> red)
      CONFIG.LANE_DIR = { x: dx / len, y: dy / len };

      // Perpendicular vector (for lane width)
      CONFIG.LANE_PERP = { x: -dy / len, y: dx / len };

      // Lane extends from base CENTER to base CENTER
      // The base platforms will render ON TOP of the lane ends
      CONFIG.LANE_START = {
        x: CONFIG.BLUE_BASE.x,
        y: CONFIG.BLUE_BASE.y
      };

      CONFIG.LANE_END = {
        x: CONFIG.RED_BASE.x,
        y: CONFIG.RED_BASE.y
      };
    })();

    // Dark Fantasy Color Palette
    const COLORS = {
      blue: {
        dark: '#1a2a3a',
        mid: '#3a5a7a',
        light: '#6b9ac4',
        glow: '#4a8ac4'
      },
      red: {
        dark: '#3a1a1a',
        mid: '#7a3a3a',
        light: '#c45c5c',
        glow: '#c44a4a'
      },
      stone: {
        dark: '#2a2520',
        mid: '#4a4540',
        light: '#6a6560'
      },
      gold: '#d4a74a',
      health: '#8b6930'
    };

    // =============================================
    // GAME STATE
    // =============================================
    const gameState = {
      running: true,
      speed: 1,
      matchTime: 0,
      zoom: 0.6,  // Start zoomed out to see the longer lane
      panX: 0,
      panY: 0,

      blueTeam: { kills: 0, gold: 500, towers: [], nexus: null, champions: [], minions: [] },
      redTeam: { kills: 0, gold: 500, towers: [], nexus: null, champions: [], minions: [] },

      commentary: [],
      lastMinionSpawn: { blue: 0, red: 0 },
      particles: []
    };

    // =============================================
    // UTILITY
    // =============================================
    const lerp = (a, b, t) => a + (b - a) * t;
    const lerpPt = (p1, p2, t) => ({ x: lerp(p1.x, p2.x, t), y: lerp(p1.y, p2.y, t) });
    const dist = (a, b) => Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
    const norm = (a, b) => { const d = dist(a, b); return d === 0 ? { x: 0, y: 0 } : { x: (b.x - a.x) / d, y: (b.y - a.y) / d }; };
    const fmtTime = s => `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;

    // =============================================
    // UNITS
    // =============================================
    class Unit {
      constructor(team, x, y) {
        this.team = team;
        this.x = x; this.y = y;
        this.hp = 100; this.maxHp = 100;
        this.damage = 10;
        this.attackRange = CONFIG.ATTACK_RANGE;
        this.attackCd = 1000;
        this.lastAtk = 0;
        this.speed = 50;
        this.dead = false;
        this.target = null;
      }

      takeDamage(amt, attacker) {
        this.hp -= amt;
        if (this.hp <= 0) { this.hp = 0; this.dead = true; this.onDeath(attacker); }
      }

      onDeath(killer) {}

      update(dt, now) {
        if (this.dead) return;
        if (!this.target || this.target.dead) this.target = this.findTarget();

        if (this.target) {
          const d = dist(this, this.target);
          if (d <= this.attackRange) {
            if (now - this.lastAtk >= this.attackCd) {
              this.target.takeDamage(this.damage, this);
              this.lastAtk = now;
            }
          } else {
            this.moveToward(this.target, dt);
          }
        } else {
          this.moveDownLane(dt);
        }
      }

      moveToward(tgt, dt) {
        const dir = norm(this, tgt);
        this.x += dir.x * this.speed * dt;
        this.y += dir.y * this.speed * dt;
      }

      moveDownLane(dt) {}
      findTarget() { return null; }
    }

    class Minion extends Unit {
      constructor(team, x, y) {
        super(team, x, y);
        this.hp = this.maxHp = 200;
        this.damage = 10;
        this.speed = CONFIG.MINION_SPEED;
        this.goldValue = 20;
        this.type = 'minion';
      }

      moveDownLane(dt) {
        const tgt = this.team === 'blue' ? CONFIG.LANE_END : CONFIG.LANE_START;
        const dir = norm(this, tgt);
        this.x += dir.x * this.speed * dt;
        this.y += dir.y * this.speed * dt;
      }

      findTarget() {
        const enemies = this.team === 'blue'
          ? [...gameState.redTeam.minions, ...gameState.redTeam.champions]
          : [...gameState.blueTeam.minions, ...gameState.blueTeam.champions];
        const towers = this.team === 'blue' ? gameState.redTeam.towers : gameState.blueTeam.towers;
        const all = [...enemies.filter(e => !e.dead), ...towers.filter(t => !t.dead)];

        let closest = null, closestD = 150;
        for (const e of all) {
          const d = dist(this, e);
          if (d < closestD) { closest = e; closestD = d; }
        }
        return closest;
      }

      onDeath(killer) {
        if (killer?.team) {
          (killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam).gold += this.goldValue;
        }
      }
    }

    class Champion extends Unit {
      constructor(team, name, x, y) {
        super(team, x, y);
        this.name = name;
        this.hp = this.maxHp = 800;
        this.mana = this.maxMana = 400;
        this.level = 1;
        this.damage = 45;
        this.speed = CONFIG.CHAMPION_SPEED;
        this.respawnTime = 0;
        this.type = 'champion';
      }

      findTarget() {
        const enemies = this.team === 'blue'
          ? [...gameState.redTeam.minions, ...gameState.redTeam.champions]
          : [...gameState.blueTeam.minions, ...gameState.blueTeam.champions];

        let closest = null, closestD = 200;
        for (const e of enemies) {
          if (e.dead) continue;
          const d = dist(this, e);
          if (d < closestD) { closest = e; closestD = d; }
        }
        return closest;
      }

      moveDownLane(dt) {
        const center = lerpPt(CONFIG.LANE_START, CONFIG.LANE_END, 0.5);
        if (dist(this, center) > 120) {
          const dir = norm(this, center);
          this.x += dir.x * this.speed * dt;
          this.y += dir.y * this.speed * dt;
        }
      }

      onDeath(killer) {
        this.respawnTime = 10 + this.level * 2;
        if (killer?.team) {
          const team = killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam;
          team.kills++;
          team.gold += 300;
          addCommentary(`${killer.name || 'Minion'} has felled ${this.name}!`, 'kill');
        }
      }

      respawn() {
        // Respawn at base center with perpendicular spread
        const base = this.team === 'blue' ? CONFIG.BLUE_BASE : CONFIG.RED_BASE;
        const perpOffset = (Math.random() - 0.5) * 40;
        this.x = base.x + CONFIG.LANE_PERP.x * perpOffset;
        this.y = base.y + CONFIG.LANE_PERP.y * perpOffset;
        this.hp = this.maxHp;
        this.mana = this.maxMana;
        this.dead = false;
        this.target = null;
        this.level = Math.min(18, this.level + 1);
      }
    }

    class Tower extends Unit {
      constructor(team, x, y, isOuter) {
        super(team, x, y);
        this.hp = this.maxHp = 3000;
        this.damage = 180;
        this.attackRange = CONFIG.TOWER_RANGE;
        this.isOuter = isOuter;
        this.type = 'tower';
      }

      moveToward() {}
      moveDownLane() {}

      findTarget() {
        const minions = this.team === 'blue' ? gameState.redTeam.minions : gameState.blueTeam.minions;
        const champs = this.team === 'blue' ? gameState.redTeam.champions : gameState.blueTeam.champions;

        for (const m of minions) if (!m.dead && dist(this, m) <= this.attackRange) return m;
        for (const c of champs) if (!c.dead && dist(this, c) <= this.attackRange) return c;
        return null;
      }

      update(dt, now) {
        if (this.dead) return;
        this.target = this.findTarget();
        if (this.target && now - this.lastAtk >= this.attackCd) {
          this.target.takeDamage(this.damage, this);
          this.lastAtk = now;
        }
      }

      onDeath(killer) {
        if (killer?.team) {
          (killer.team === 'blue' ? gameState.blueTeam : gameState.redTeam).gold += 200;
          addCommentary(`The ${this.team} tower has fallen!`, 'objective');
        }
      }
    }

    class Nexus extends Unit {
      constructor(team, x, y) {
        super(team, x, y);
        this.hp = this.maxHp = 5000;
        this.type = 'nexus';
      }
      moveToward() {}
      moveDownLane() {}
      findTarget() { return null; }
      update() {}
      onDeath() {
        addCommentary(`The ${this.team === 'blue' ? 'Red' : 'Blue'} Covenant is VICTORIOUS!`, 'objective');
        gameState.running = false;
      }
    }

    // =============================================
    // GAME INIT
    // =============================================
    function initGame() {
      // Place towers along the lane
      CONFIG.BLUE_TOWERS.forEach((t, i) => {
        const p = lerpPt(CONFIG.LANE_START, CONFIG.LANE_END, t);
        gameState.blueTeam.towers.push(new Tower('blue', p.x, p.y, i === 0));
      });
      CONFIG.RED_TOWERS.forEach((t, i) => {
        const p = lerpPt(CONFIG.LANE_START, CONFIG.LANE_END, t);
        gameState.redTeam.towers.push(new Tower('red', p.x, p.y, i === 0));
      });

      // Place nexus at BASE CENTERS (not offset from lane)
      gameState.blueTeam.nexus = new Nexus('blue', CONFIG.BLUE_BASE.x, CONFIG.BLUE_BASE.y);
      gameState.redTeam.nexus = new Nexus('red', CONFIG.RED_BASE.x, CONFIG.RED_BASE.y);

      // Spawn champions in their base areas (spread perpendicular to lane)
      const names = ['Ironclad', 'Voltaic', 'Shadebow'];
      names.forEach((name, i) => {
        const offset = (i - 1) * 30; // -30, 0, 30 perpendicular spread
        gameState.blueTeam.champions.push(new Champion('blue', name,
          CONFIG.BLUE_BASE.x + CONFIG.LANE_PERP.x * offset,
          CONFIG.BLUE_BASE.y + CONFIG.LANE_PERP.y * offset
        ));
        gameState.redTeam.champions.push(new Champion('red', name,
          CONFIG.RED_BASE.x + CONFIG.LANE_PERP.x * offset,
          CONFIG.RED_BASE.y + CONFIG.LANE_PERP.y * offset
        ));
      });

      addCommentary('The battle for the Molten Throne begins...', 'objective');
      addCommentary('Warriors gather at their fortresses.', '');
    }

    function spawnMinion(team) {
      // Spawn minions from the base area (near lane start/end)
      const base = team === 'blue' ? CONFIG.BLUE_BASE : CONFIG.RED_BASE;
      const perpOffset = (Math.random() - 0.5) * 30; // Spread perpendicular to lane
      const m = new Minion(team,
        base.x + CONFIG.LANE_PERP.x * perpOffset,
        base.y + CONFIG.LANE_PERP.y * perpOffset
      );
      (team === 'blue' ? gameState.blueTeam : gameState.redTeam).minions.push(m);
    }

    // =============================================
    // GAME LOOP
    // =============================================
    let lastTime = 0;

    function gameLoop(ts) {
      const dt = Math.min((ts - lastTime) / 1000, 0.1) * gameState.speed;
      lastTime = ts;

      if (gameState.running) {
        gameState.matchTime += dt;
        const now = gameState.matchTime * 1000;

        if (now - gameState.lastMinionSpawn.blue >= CONFIG.MINION_SPAWN_INTERVAL) {
          spawnMinion('blue');
          gameState.lastMinionSpawn.blue = now;
        }
        if (now - gameState.lastMinionSpawn.red >= CONFIG.MINION_SPAWN_INTERVAL) {
          spawnMinion('red');
          gameState.lastMinionSpawn.red = now;
        }

        const all = [
          ...gameState.blueTeam.towers, ...gameState.redTeam.towers,
          ...gameState.blueTeam.champions, ...gameState.redTeam.champions,
          ...gameState.blueTeam.minions, ...gameState.redTeam.minions,
        ];
        all.forEach(u => u.update(dt, now));

        [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(c => {
          if (c.dead && c.respawnTime > 0) {
            c.respawnTime -= dt;
            if (c.respawnTime <= 0) c.respawn();
          }
        });

        gameState.blueTeam.minions = gameState.blueTeam.minions.filter(m => !m.dead);
        gameState.redTeam.minions = gameState.redTeam.minions.filter(m => !m.dead);
      }

      render();
      updateUI();
      requestAnimationFrame(gameLoop);
    }

    // =============================================
    // SVG RENDERING - Dark Fantasy Style
    // =============================================
    const svg = document.getElementById('gameSvg');
    const groundLayer = document.getElementById('groundLayer');
    const laneLayer = document.getElementById('laneLayer');
    const effectsLayer = document.getElementById('effectsLayer');
    const unitsLayer = document.getElementById('unitsLayer');
    const minimapSvg = document.getElementById('minimapSvg');

    function updateViewBox() {
      const w = CONFIG.WORLD_W / gameState.zoom;
      const h = CONFIG.WORLD_H / gameState.zoom;
      const x = (CONFIG.WORLD_W - w) / 2 + gameState.panX;
      const y = (CONFIG.WORLD_H - h) / 2 + gameState.panY;
      svg.setAttribute('viewBox', `${x} ${y} ${w} ${h}`);
    }

    function render() {
      updateViewBox();
      renderGround();
      renderLane();
      renderUnits();
      renderMinimap();
    }

    function renderGround() {
      groundLayer.innerHTML = '';
      const { cx, cy, width, height } = CONFIG.GROUND;

      // Main ground - dark earth
      const ground = createSVG('polygon', {
        points: `${cx},${cy - height/2} ${cx + width/2},${cy} ${cx},${cy + height/2} ${cx - width/2},${cy}`,
        fill: 'url(#groundGrad)',
        opacity: '0.95'
      });
      groundLayer.appendChild(ground);

      // Subtle grid for depth
      const gridGroup = createSVG('g', { stroke: '#2a2520', 'stroke-width': '1', opacity: '0.25' });
      for (let i = -10; i <= 10; i++) {
        const offset = i * (width / 20);
        const line = createSVG('line', {
          x1: cx + offset / 2,
          y1: cy - height / 2 + Math.abs(offset) * 0.53,
          x2: cx + offset / 2,
          y2: cy + height / 2 - Math.abs(offset) * 0.53
        });
        gridGroup.appendChild(line);
      }
      groundLayer.appendChild(gridGroup);

      // Ambient particles (floating dust/embers)
      for (let i = 0; i < 15; i++) {
        const px = cx + (Math.random() - 0.5) * width * 0.8;
        const py = cy + (Math.random() - 0.5) * height * 0.8;
        const particle = createSVG('circle', {
          cx: px, cy: py,
          r: 1 + Math.random() * 2,
          fill: '#d4a74a',
          opacity: 0.1 + Math.random() * 0.2
        });
        groundLayer.appendChild(particle);
      }
    }

    function renderBase(base, team) {
      const { x, y } = base;
      const r = CONFIG.BASE_RADIUS;
      const col = COLORS[team];

      const platformGroup = createSVG('g', {});

      // Large fortress area - isometric diamond

      // Outer shadow
      platformGroup.appendChild(createSVG('ellipse', {
        cx: x + 8, cy: y + 15,
        rx: r * 1.1, ry: r * 0.55,
        fill: '#000',
        opacity: '0.4'
      }));

      // Outer fortress wall/boundary
      platformGroup.appendChild(createSVG('polygon', {
        points: `${x},${y - r * 0.55} ${x + r * 1.05},${y} ${x},${y + r * 0.55} ${x - r * 1.05},${y}`,
        fill: '#1a1815',
        stroke: col.dark,
        'stroke-width': '4'
      }));

      // Main fortress floor
      platformGroup.appendChild(createSVG('polygon', {
        points: `${x},${y - r * 0.5} ${x + r},${y} ${x},${y + r * 0.5} ${x - r},${y}`,
        fill: COLORS.stone.dark,
        stroke: col.mid,
        'stroke-width': '2'
      }));

      // Inner courtyard
      const innerR = r * 0.6;
      platformGroup.appendChild(createSVG('polygon', {
        points: `${x},${y - innerR * 0.5} ${x + innerR},${y} ${x},${y + innerR * 0.5} ${x - innerR},${y}`,
        fill: COLORS.stone.mid,
        opacity: '0.7'
      }));

      // Decorative corner towers (visual only)
      const corners = [
        { cx: x, cy: y - r * 0.5 },
        { cx: x + r, cy: y },
        { cx: x, cy: y + r * 0.5 },
        { cx: x - r, cy: y }
      ];
      corners.forEach(corner => {
        platformGroup.appendChild(createSVG('circle', {
          cx: corner.cx, cy: corner.cy, r: 12,
          fill: col.dark,
          stroke: col.mid,
          'stroke-width': '2'
        }));
      });

      // Team glow emanating from center
      platformGroup.appendChild(createSVG('ellipse', {
        cx: x, cy: y,
        rx: r * 0.4, ry: r * 0.2,
        fill: col.glow,
        opacity: '0.3',
        filter: `url(#${team}Glow)`
      }));

      return platformGroup;
    }

    function renderLane() {
      laneLayer.innerHTML = '';
      const { LANE_START: start, LANE_END: end, LANE_WIDTH: w, LANE_PERP: perp } = CONFIG;

      // Use pre-computed perpendicular vector
      const px = perp.x * w / 2;
      const py = perp.y * w / 2;

      // Stone path base (slightly wider for shadow effect)
      // Lane runs from base center to base center
      const laneBase = createSVG('polygon', {
        points: `${start.x + px * 1.3},${start.y + py * 1.3} ${end.x + px * 1.3},${end.y + py * 1.3} ${end.x - px * 1.3},${end.y - py * 1.3} ${start.x - px * 1.3},${start.y - py * 1.3}`,
        fill: '#1a1815',
        opacity: '0.9'
      });
      laneLayer.appendChild(laneBase);

      // Main stone lane
      const lane = createSVG('polygon', {
        points: `${start.x + px},${start.y + py} ${end.x + px},${end.y + py} ${end.x - px},${end.y - py} ${start.x - px},${start.y - py}`,
        fill: 'url(#laneGrad)',
        stroke: '#3d3530',
        'stroke-width': '2'
      });
      laneLayer.appendChild(lane);

      // Render base platforms AFTER lane (on top) - covers lane ends cleanly
      laneLayer.appendChild(renderBase(CONFIG.BLUE_BASE, 'blue'));
      laneLayer.appendChild(renderBase(CONFIG.RED_BASE, 'red'));

      // Lane markings - ancient runes along the path
      const numRunes = 12;
      for (let i = 1; i < numRunes; i++) {
        const t = i / numRunes;
        const p = lerpPt(start, end, t);
        const rune = createSVG('circle', {
          cx: p.x, cy: p.y,
          r: 4,
          fill: 'none',
          stroke: t < 0.5 ? '#4a7a9c' : '#9c4a4a',
          'stroke-width': '1',
          opacity: '0.3'
        });
        laneLayer.appendChild(rune);
      }

      // Center battle marker
      const center = lerpPt(start, end, 0.5);
      const centerMark = createSVG('polygon', {
        points: `${center.x},${center.y - 15} ${center.x + 13},${center.y} ${center.x},${center.y + 15} ${center.x - 13},${center.y}`,
        fill: 'none',
        stroke: '#d4a74a',
        'stroke-width': '2',
        opacity: '0.4'
      });
      laneLayer.appendChild(centerMark);
    }

    function renderUnits() {
      unitsLayer.innerHTML = '';

      const units = [
        gameState.blueTeam.nexus, gameState.redTeam.nexus,
        ...gameState.blueTeam.towers, ...gameState.redTeam.towers,
        ...gameState.blueTeam.minions, ...gameState.redTeam.minions,
        ...gameState.blueTeam.champions, ...gameState.redTeam.champions,
      ].filter(u => u && !u.dead);

      units.sort((a, b) => a.y - b.y);

      units.forEach(u => {
        if (u.type === 'nexus') renderNexus(u);
        else if (u.type === 'tower') renderTower(u);
        else if (u.type === 'minion') renderMinion(u);
        else if (u.type === 'champion') renderChampion(u);
      });

      [...gameState.blueTeam.champions, ...gameState.redTeam.champions]
        .filter(c => c.dead)
        .forEach(renderDeadChamp);
    }

    function renderNexus(nexus) {
      const { x, y } = nexus;
      const g = createSVG('g', { transform: `translate(${x}, ${y})` });
      const col = COLORS[nexus.team];

      // Stone platform base
      const platform = createSVG('polygon', {
        points: '-50,25 0,-15 50,25 0,65',
        fill: COLORS.stone.dark,
        stroke: COLORS.stone.mid,
        'stroke-width': '2'
      });
      g.appendChild(platform);

      // Platform detail
      const platformInner = createSVG('polygon', {
        points: '-35,25 0,-5 35,25 0,55',
        fill: COLORS.stone.mid,
        opacity: '0.5'
      });
      g.appendChild(platformInner);

      // Crystal monument - left face
      const leftFace = createSVG('polygon', {
        points: '0,-15 0,-75 -25,-50 -25,10',
        fill: col.mid
      });
      g.appendChild(leftFace);

      // Crystal monument - right face
      const rightFace = createSVG('polygon', {
        points: '0,-15 0,-75 25,-50 25,10',
        fill: col.light
      });
      g.appendChild(rightFace);

      // Crystal top
      const crystalTop = createSVG('polygon', {
        points: '-25,-50 0,-75 25,-50 0,-25',
        fill: col.light,
        opacity: '0.8'
      });
      g.appendChild(crystalTop);

      // Glow effect
      const glow = createSVG('ellipse', {
        cx: '0', cy: '30',
        rx: '40', ry: '20',
        fill: col.glow,
        opacity: '0.15',
        filter: `url(#${nexus.team}Glow)`
      });
      g.appendChild(glow);

      // Health bar
      renderHealthBar(g, 0, -90, nexus.hp, nexus.maxHp, 60, col.mid);

      unitsLayer.appendChild(g);
    }

    function renderTower(tower) {
      const { x, y } = tower;
      const g = createSVG('g', { transform: `translate(${x}, ${y})`, filter: 'url(#shadow)' });
      const col = COLORS[tower.team];

      // Shadow
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '18', rx: '20', ry: '10',
        fill: '#000', opacity: '0.4'
      }));

      // Stone base
      g.appendChild(createSVG('polygon', {
        points: '-18,15 0,0 18,15 0,30',
        fill: COLORS.stone.dark,
        stroke: COLORS.stone.mid,
        'stroke-width': '1'
      }));

      // Tower body - stone pillar
      g.appendChild(createSVG('rect', {
        x: '-12', y: '-55', width: '24', height: '65',
        fill: COLORS.stone.mid,
        stroke: COLORS.stone.dark,
        'stroke-width': '1',
        rx: '2'
      }));

      // Tower battlements
      for (let i = -1; i <= 1; i++) {
        g.appendChild(createSVG('rect', {
          x: -15 + i * 10, y: '-65', width: '8', height: '12',
          fill: COLORS.stone.light
        }));
      }

      // Colored crystal on top
      g.appendChild(createSVG('polygon', {
        points: '0,-75 -8,-60 8,-60',
        fill: col.light,
        filter: `url(#${tower.team}Glow)`
      }));

      // Attack beam
      if (tower.target && !tower.target.dead) {
        g.appendChild(createSVG('line', {
          x1: '0', y1: '-65',
          x2: tower.target.x - x, y2: tower.target.y - y - 15,
          stroke: col.glow,
          'stroke-width': '3',
          opacity: '0.7'
        }));
      }

      renderHealthBar(g, 0, -85, tower.hp, tower.maxHp, 45);

      unitsLayer.appendChild(g);
    }

    function renderMinion(minion) {
      const { x, y } = minion;
      const g = createSVG('g', { transform: `translate(${x}, ${y})` });
      const col = COLORS[minion.team];

      // Shadow
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '8', rx: '8', ry: '4',
        fill: '#000', opacity: '0.3'
      }));

      // Body - armored creature
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '0', rx: '10', ry: '8',
        fill: col.mid
      }));

      // Armor highlight
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '-2', rx: '8', ry: '5',
        fill: col.light,
        opacity: '0.6'
      }));

      // Eyes/visor
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '-3', rx: '4', ry: '2',
        fill: col.dark,
        opacity: '0.8'
      }));

      if (minion.hp < minion.maxHp) {
        renderHealthBar(g, 0, -16, minion.hp, minion.maxHp, 18);
      }

      unitsLayer.appendChild(g);
    }

    function renderChampion(champ) {
      const { x, y } = champ;
      const g = createSVG('g', { transform: `translate(${x}, ${y})`, filter: 'url(#shadow)' });
      const col = COLORS[champ.team];

      // Shadow
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '20', rx: '22', ry: '11',
        fill: '#000', opacity: '0.5'
      }));

      // Selection ring
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '14', rx: '25', ry: '12',
        fill: 'none',
        stroke: col.glow,
        'stroke-width': '2',
        opacity: '0.5'
      }));

      // Body armor
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '0', rx: '18', ry: '16',
        fill: `url(#${champ.team}Grad)`,
        stroke: col.dark,
        'stroke-width': '1'
      }));

      // Armor detail
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '-4', rx: '14', ry: '12',
        fill: col.mid,
        opacity: '0.4'
      }));

      // Head/Helm
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '-20', rx: '12', ry: '10',
        fill: col.light,
        stroke: col.mid,
        'stroke-width': '1'
      }));

      // Visor/Face
      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '-18', rx: '6', ry: '4',
        fill: col.dark,
        opacity: '0.7'
      }));

      // Name plate
      g.appendChild(createSVG('rect', {
        x: '-35', y: '-52', width: '70', height: '16',
        fill: 'rgba(13,11,9,0.85)',
        rx: '2'
      }));

      const label = createSVG('text', {
        x: '0', y: '-40',
        'text-anchor': 'middle',
        fill: '#d4c4a8',
        'font-size': '11',
        'font-family': 'inherit'
      });
      label.textContent = `${champ.name} Lv${champ.level}`;
      g.appendChild(label);

      renderHealthBar(g, 0, -58, champ.hp, champ.maxHp, 50);

      // Level badge
      g.appendChild(createSVG('circle', {
        cx: '22', cy: '-35', r: '10',
        fill: '#0d0b09',
        stroke: COLORS.gold,
        'stroke-width': '1'
      }));

      const lvlText = createSVG('text', {
        x: '22', y: '-31',
        'text-anchor': 'middle',
        fill: COLORS.gold,
        'font-size': '10',
        'font-weight': 'bold'
      });
      lvlText.textContent = champ.level;
      g.appendChild(lvlText);

      unitsLayer.appendChild(g);
    }

    function renderDeadChamp(champ) {
      const { x, y } = champ;
      const g = createSVG('g', { transform: `translate(${x}, ${y})`, opacity: '0.35' });

      g.appendChild(createSVG('ellipse', {
        cx: '0', cy: '0', rx: '18', ry: '10',
        fill: '#3a3530',
        stroke: '#5a5550',
        'stroke-width': '1',
        'stroke-dasharray': '4'
      }));

      const letter = createSVG('text', {
        x: '0', y: '5',
        'text-anchor': 'middle',
        fill: '#8a7a6a',
        'font-size': '12'
      });
      letter.textContent = champ.name[0];
      g.appendChild(letter);

      if (champ.respawnTime > 0) {
        const timer = createSVG('text', {
          x: '0', y: '28',
          'text-anchor': 'middle',
          fill: '#5a4a3a',
          'font-size': '11'
        });
        timer.textContent = `${Math.ceil(champ.respawnTime)}s`;
        g.appendChild(timer);
      }

      unitsLayer.appendChild(g);
    }

    function renderHealthBar(parent, x, y, hp, maxHp, width, color = COLORS.health) {
      const pct = Math.max(0, hp / maxHp);

      parent.appendChild(createSVG('rect', {
        x: x - width / 2, y: y,
        width: width, height: '6',
        fill: '#1a1815',
        stroke: '#3d3530',
        'stroke-width': '1',
        rx: '2'
      }));

      let fillColor = color;
      if (color === COLORS.health) {
        if (pct < 0.3) fillColor = '#8b3030';
        else if (pct < 0.6) fillColor = '#8b6930';
      }

      parent.appendChild(createSVG('rect', {
        x: x - width / 2 + 1, y: y + 1,
        width: Math.max(0, (width - 2) * pct), height: '4',
        fill: fillColor,
        rx: '1'
      }));
    }

    function renderMinimap() {
      minimapSvg.innerHTML = '';

      minimapSvg.appendChild(createSVG('rect', {
        width: '220', height: '130',
        fill: '#0d0b09'
      }));

      const scaleX = 220 / CONFIG.WORLD_W;
      const scaleY = 130 / CONFIG.WORLD_H;

      // Ground
      const { cx, cy, width, height } = CONFIG.GROUND;
      minimapSvg.appendChild(createSVG('polygon', {
        points: `${cx * scaleX},${(cy - height/2) * scaleY} ${(cx + width/2) * scaleX},${cy * scaleY} ${cx * scaleX},${(cy + height/2) * scaleY} ${(cx - width/2) * scaleX},${cy * scaleY}`,
        fill: '#1a1815',
        stroke: '#2a2520'
      }));

      // Base platforms on minimap
      [
        { base: CONFIG.BLUE_BASE, col: COLORS.blue },
        { base: CONFIG.RED_BASE, col: COLORS.red }
      ].forEach(({ base, col }) => {
        const bx = base.x * scaleX;
        const by = base.y * scaleY;
        const br = CONFIG.BASE_RADIUS * scaleX;
        minimapSvg.appendChild(createSVG('polygon', {
          points: `${bx},${by - br * 0.5} ${bx + br},${by} ${bx},${by + br * 0.5} ${bx - br},${by}`,
          fill: col.dark,
          stroke: col.mid,
          'stroke-width': '1'
        }));
      });

      // Lane
      minimapSvg.appendChild(createSVG('line', {
        x1: CONFIG.LANE_START.x * scaleX, y1: CONFIG.LANE_START.y * scaleY,
        x2: CONFIG.LANE_END.x * scaleX, y2: CONFIG.LANE_END.y * scaleY,
        stroke: '#3a3530',
        'stroke-width': '6',
        'stroke-linecap': 'round'
      }));

      // Nexus (at base centers)
      [[gameState.blueTeam.nexus, COLORS.blue.light], [gameState.redTeam.nexus, COLORS.red.light]].forEach(([n, c]) => {
        if (!n) return;
        const nx = n.x * scaleX, ny = n.y * scaleY;
        minimapSvg.appendChild(createSVG('polygon', {
          points: `${nx},${ny - 6} ${nx + 7},${ny + 2} ${nx},${ny + 6} ${nx - 7},${ny + 2}`,
          fill: c
        }));
      });

      // Towers
      [...gameState.blueTeam.towers, ...gameState.redTeam.towers].forEach(t => {
        if (t.dead) return;
        minimapSvg.appendChild(createSVG('rect', {
          x: t.x * scaleX - 3, y: t.y * scaleY - 5,
          width: '6', height: '10',
          fill: COLORS[t.team].mid
        }));
      });

      // Champions
      [...gameState.blueTeam.champions, ...gameState.redTeam.champions].forEach(c => {
        if (c.dead) return;
        minimapSvg.appendChild(createSVG('circle', {
          cx: c.x * scaleX, cy: c.y * scaleY, r: '5',
          fill: COLORS[c.team].light,
          stroke: '#d4c4a8',
          'stroke-width': '1'
        }));
      });

      // Minions
      [...gameState.blueTeam.minions, ...gameState.redTeam.minions].forEach(m => {
        minimapSvg.appendChild(createSVG('circle', {
          cx: m.x * scaleX, cy: m.y * scaleY, r: '2',
          fill: COLORS[m.team].mid
        }));
      });
    }

    function createSVG(tag, attrs = {}) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
      return el;
    }

    // =============================================
    // UI
    // =============================================
    function updateUI() {
      document.getElementById('matchTime').textContent = fmtTime(gameState.matchTime);
      document.getElementById('blueKills').textContent = gameState.blueTeam.kills;
      document.getElementById('redKills').textContent = gameState.redTeam.kills;

      updatePortraits();
      updateTeamPanels();
    }

    function updatePortraits() {
      ['blue', 'red'].forEach(team => {
        const container = document.getElementById(team + 'Portraits');
        const champs = gameState[team + 'Team'].champions;
        container.innerHTML = champs.map(c => `
          <div class="portrait ${team} ${c.dead ? 'dead' : ''}">
            ${c.name[0]}
            <span class="level">${c.level}</span>
            <div class="bars">
              <div class="hp-bar"><div class="fill" style="width:${(c.hp/c.maxHp)*100}%"></div></div>
              <div class="mp-bar"><div class="fill" style="width:${(c.mana/c.maxMana)*100}%"></div></div>
            </div>
          </div>
        `).join('');
      });
    }

    function updateTeamPanels() {
      ['blue', 'red'].forEach(team => {
        const panel = document.getElementById(team + 'TeamPanel');
        const champs = gameState[team + 'Team'].champions;
        panel.innerHTML = champs.map(c => `
          <div class="champ-row">
            <div class="champ-icon ${team}">${c.name[0]}</div>
            <div class="champ-details">
              <div class="champ-name">${c.name}</div>
              <div class="champ-level">Level ${c.level}</div>
              <div class="champ-hp-bar"><div class="fill" style="width:${(c.hp/c.maxHp)*100}%"></div></div>
            </div>
          </div>
        `).join('');
      });
    }

    function addCommentary(text, type = '') {
      gameState.commentary.unshift({ text, type });
      if (gameState.commentary.length > 6) gameState.commentary.pop();

      document.getElementById('commentaryLines').innerHTML = gameState.commentary.map(c =>
        `<div class="commentary-line ${c.type}">${c.text}</div>`
      ).join('');
    }

    // =============================================
    // INPUT
    // =============================================
    function setupInput() {
      document.getElementById('playPauseBtn').onclick = e => {
        gameState.running = !gameState.running;
        e.target.textContent = gameState.running ? 'Pause' : 'Play';
        e.target.classList.toggle('active', gameState.running);
      };

      document.getElementById('speedBtn').onclick = e => {
        const speeds = [1, 2, 4, 0.5];
        gameState.speed = speeds[(speeds.indexOf(gameState.speed) + 1) % speeds.length];
        e.target.textContent = gameState.speed + 'x';
      };

      document.getElementById('resetBtn').onclick = () => location.reload();

      document.getElementById('zoomInBtn').onclick = () => {
        gameState.zoom = Math.min(3, gameState.zoom + 0.2);
      };

      document.getElementById('zoomOutBtn').onclick = () => {
        gameState.zoom = Math.max(0.25, gameState.zoom - 0.2);
      };

      const gameArea = document.getElementById('gameArea');

      // Mouse wheel zoom
      gameArea.addEventListener('wheel', e => {
        e.preventDefault();
        if (e.deltaY < 0) gameState.zoom = Math.min(3, gameState.zoom + 0.1);
        else gameState.zoom = Math.max(0.25, gameState.zoom - 0.1);
      });

      // Mouse drag panning
      let isDragging = false;
      let lastMouseX = 0;
      let lastMouseY = 0;

      gameArea.addEventListener('mousedown', e => {
        if (e.button === 0) { // Left click
          isDragging = true;
          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
          gameArea.style.cursor = 'grabbing';
        }
      });

      document.addEventListener('mousemove', e => {
        if (isDragging) {
          const dx = e.clientX - lastMouseX;
          const dy = e.clientY - lastMouseY;

          // Adjust pan based on zoom level (more zoomed = less pan needed)
          const panSpeed = 1.5 / gameState.zoom;
          gameState.panX -= dx * panSpeed;
          gameState.panY -= dy * panSpeed;

          // Clamp panning to reasonable bounds
          const maxPan = CONFIG.WORLD_W * 0.5;
          gameState.panX = Math.max(-maxPan, Math.min(maxPan, gameState.panX));
          gameState.panY = Math.max(-maxPan, Math.min(maxPan, gameState.panY));

          lastMouseX = e.clientX;
          lastMouseY = e.clientY;
        }
      });

      document.addEventListener('mouseup', e => {
        if (e.button === 0) {
          isDragging = false;
          gameArea.style.cursor = 'grab';
        }
      });

      // Set initial cursor
      gameArea.style.cursor = 'grab';
    }

    // =============================================
    // INIT
    // =============================================
    setupInput();
    initGame();
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
